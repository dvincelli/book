<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Signal Processing - OCaml Scientific Computing</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing</h1><h5>1<sup>st</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.xyz/package/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="signal-processing">
<h1>Signal Processing</h1>
<p>TODO: refer to https://scipy.github.io/devdocs/tutorial/signal.html. Try to implement its examples first.</p>
<p>So it’s basically a bit of explanation + a lot examples for this chapter.</p>
<section class="level2" id="fourier-transform">
<h2>Fourier Transform</h2>
<p>Think about an audio that lasts for 10 seconds. This audio can surely be described in the <em>time domain</em>, which means plotting its sound intensity against time as x axis. On the other hand, maybe less obviously, the sound can also be described in the <em>frequency domain</em>. For example, if all the 10 seconds are filled with only playing the A# note, then you can describe this whole audio with one frequency number: 466.16 Hz. If it’s a C note, then the number is 523.25 Hz, etc. The thing is that, the real-world sound is not always so pure, they are quite likely compounded from different frequencies. Perhaps this 10 seconds are about water flowing, or wind whispering, what frequencies it is built from then?</p>
<p>That’s where Discrete Fourier Transform (DFT) comes into play. It captures the idea of converting the two form of representing a signal: in time domain and in frequency domain. We can represent a signal with the values of some quantity <span class="math inline">\(h\)</span> as a function of time: <span class="math inline">\(h(t)\)</span>, or this signal can be represented by giving its amplitude <span class="math inline">\(H\)</span> as function of frequency: <span class="math inline">\(H(f)\)</span>. We can think they are two representation of the same thing, and Fourier Transform change between them:</p>
<p><span class="math display">\[ h(f) = \int H(f)\exp^{-2\pi~ift}df\]</span> <span class="math display">\[ H(f) = \int h(t)\exp^{2\pi~ift}dt\]</span></p>
<p>To put it simply: suppose Alice mix a unknown number of colour together, and let Bob to guess what those colours are, then perhaps Bob need a Fourier Transform machine of sorts.</p>
<p>(ADD: description of DFT)</p>
<p>You might be wondering, it’s cool that I can recognise how a sound is composed, but so what? Think of a classic example where you need to remove some high pitch noisy from some music. By using DFT, you can easily find out the frequency of this noisy, remove this frequency, and turn the signal back to the time domain by using something a reverse process.</p>
<p>Actually, the application of DFT is more than on sound signal processing. (EXAMPLES). It covers a very large of important computation problems that spans many fields and applications, such as music processing, data compressing, image processing, engineering, mathematics, etc.</p>
</section>
<section class="level2" id="fast-fourier-transform">
<h2>Fast Fourier Transform</h2>
<p>The Fast Fourier Transform is an algorithm that reduces the DFT computation complexity from <span class="math inline">\(\mathcal{O}(n^2)\)</span> to <span class="math inline">\(\mathcal{O}(n\log{}n)\)</span>.</p>
<p>TODO: A brief theory about how FFT drops down to log level. Make sure you explain DFT well enough in the previous section.</p>
<p>To introduce the algorithm itself in detailed math of DFT/FFT is beyond the scope of this book, we encourage the readers to refer to other classic textbook on this topic <span data-cites="phillips2003signals" class="citation">(Phillips, Parr, and Riskin 2003)</span>.</p>
<p>Owl provides these basic FFT functions:</p>
<table>
<colgroup>
<col style="width: 45%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th>Functions</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fft ~axis x</code></td>
<td style="text-align: left;">Compute the one-dimensional discrete Fourier Transform</td>
</tr>
<tr class="even">
<td><code>ifft ~axis x</code></td>
<td style="text-align: left;">Compute the one-dimensional inverse discrete Fourier Transform</td>
</tr>
<tr class="odd">
<td><code>rfft ~axis otyp x</code></td>
<td style="text-align: left;">Compute the one-dimensional discrete Fourier Transform for real input</td>
</tr>
<tr class="even">
<td><code>irfft ~axis ~n otyp x</code></td>
<td style="text-align: left;">Compute the one-dimensional inverse discrete Fourier Transform for real input</td>
</tr>
</tbody>
</table>
<p>TODO: introduce the FFTW we interface to a bit. It’s a challenge to make FFT fast, and why FFTW works fast, etc.</p>
</section>
<section class="level2" id="small-examples">
<h2>Small examples</h2>
<p>TODO: refer to https://scipy.github.io/devdocs/tutorial/fft.html. Try all these small examples. We can remove some of them later.</p>
<section class="level3" id="d-discrete-fourier-transforms">
<h3>1-D Discrete Fourier transforms</h3>
<p><code>fft</code> and <code>ifft</code>.</p>
<div class="highlight">
<pre><code class="language-text"># let a = [|1.;2.;1.;-1.;1.5;1.0|]
val a : float array = [|1.; 2.; 1.; -1.; 1.5; 1.|]
# let b = Arr.of_array a [|6|] |&gt; Dense.Ndarray.Generic.cast_d2z
val b : (Complex.t, complex64_elt) Dense.Ndarray.Generic.t =

       C0      C1      C2       C3        C4      C5
R (1, 0i) (2, 0i) (1, 0i) (-1, 0i) (1.5, 0i) (1, 0i)

# let c = Owl_fft.D.fft b 
val c : (Complex.t, complex64_elt) Owl_dense_ndarray_generic.t =

         C0                 C1                 C2                  C3                C4                C5
R (5.5, 0i) (2.25, -0.433013i) (-2.75, -1.29904i) (1.5, 1.94289E-16i) (-2.75, 1.29904i) (2.25, 0.433013i)

# let d = Owl_fft.D.ifft c
val d : (Complex.t, complex64_elt) Owl_dense_ndarray_generic.t =

                 C0                C1                 C2                  C3                  C4                C5
R (1, 1.38778E-17i) (2, 1.15186E-15i) (1, -8.65641E-17i) (-1, -1.52188E-15i) (1.5, 1.69831E-16i) (1, 2.72882E-16i)
</code></pre>
</div>
<p>The example plots the FFT of the sum of two sines.</p>
<div class="highlight">
<pre><code class="language-text"># module G = Dense.Ndarray.Generic
module G = Owl.Dense.Ndarray.Generic

# let n = 600. (* sample points *)
val n : float = 600.
# let t = 1. /. 800. (* sample spacing *)
val t : float = 0.00125
# let x = Arr.linspace 0. (n *. t) (int_of_float n) 
val x : Arr.arr =

  C0         C1         C2         C3         C4         C595     C596     C597     C598 C599
R  0 0.00125209 0.00250417 0.00375626 0.00500835 ... 0.744992 0.746244 0.747496 0.748748 0.75

# let y1 = Arr.((50. *. 2. *. Owl_const.pi) $* x |&gt; sin)
val y1 : Arr.arr =

  C0       C1       C2      C3       C4         C595    C596     C597     C598        C599
R  0 0.383289 0.708033 0.92463 0.999997 ... 0.999997 0.92463 0.708033 0.383289 1.27376E-14

# let y2 = Arr.(0.5 $* ((80. *. 2. *. Owl_const.pi) $* x |&gt; sin))
val y2 : (float, float64_elt) Owl_dense_ndarray_generic.t =

  C0       C1       C2      C3       C4          C595     C596      C597      C598         C599
R  0 0.294317 0.475851 0.47504 0.292193 ... -0.292193 -0.47504 -0.475851 -0.294317 -2.15587E-14

# let y = Arr.(y1 + y2) |&gt; G.cast_d2z 
val y : (Complex.t, complex64_elt) G.t =

       C0             C1            C2            C3            C4               C595           C596           C597            C598               C599
R (0, 0i) (0.677606, 0i) (1.18388, 0i) (1.39967, 0i) (1.29219, 0i) ... (0.707804, 0i) (0.449591, 0i) (0.232182, 0i) (0.0889723, 0i) (-8.82117E-15, 0i)

# let yf = Owl_fft.D.fft y
val yf : (Complex.t, complex64_elt) Owl_dense_ndarray_generic.t =

             C0                    C1                    C2                    C3                  C4                     C595                 C596                   C597                   C598                   C599
R (5.01874, 0i) (5.02225, 0.0182513i) (5.03281, 0.0366004i) (5.05051, 0.0551465i) (5.0755, 0.073992i) ... (5.108, -0.0932438i) (5.0755, -0.073992i) (5.05051, -0.0551465i) (5.03281, -0.0366004i) (5.02225, -0.0182513i)

# let z = Dense.Ndarray.Z.(abs yf |&gt; re)
val z : Dense.Ndarray.Z.cast_arr =

       C0      C1      C2      C3      C4        C595    C596    C597    C598    C599
R 5.01874 5.02228 5.03294 5.05081 5.07604 ... 5.10886 5.07604 5.05081 5.03294 5.02228
</code></pre>
</div>
Plot the result.
<div class="highlight">
<pre><code class="language-text"># let h = Plot.create "plot_001.png" in 
  let xa = Arr.linspace 1. 600. 600 in
  Plot.plot ~h xa z;
  Plot.output h 
- : unit = ()</code></pre>
</div>
<figure>
<img alt="" style="width:70.0%" class="align-center" title="plot_001" src="images/signal/plot_001.png"><figcaption>Plot example 01</figcaption>
</figure>
<p><code>rfft</code> and <code>irfft</code> is for performing fft on real input.</p>
<div class="highlight">
<pre><code class="language-text"># let a = [|1.; 2.; 1.; -1.; 1.5; 1.0|]
val a : float array = [|1.; 2.; 1.; -1.; 1.5; 1.|]
# let b = Arr.of_array a [|6|]
val b : Arr.arr =
  C0 C1 C2 C3  C4 C5
R  1  2  1 -1 1.5  1


# let c = Owl_fft.D.rfft b
val c : (Complex.t, complex64_elt) Owl_dense_ndarray_generic.t =
         C0                 C1                 C2        C3
R (5.5, 0i) (2.25, -0.433013i) (-2.75, -1.29904i) (1.5, 0i)

# let d = Owl_fft.D.irfft c
val d : (float, float64_elt) Owl_dense_ndarray_generic.t =

  C0 C1 C2 C3  C4 C5
R  1  2  1 -1 1.5  1
</code></pre>
</div>
<div class="highlight">
<pre><code class="language-text"># let a = [|1.; 2.; 1.; -1.; 1.5;|]
val a : float array = [|1.; 2.; 1.; -1.; 1.5|]
# let b = Arr.of_array a [|5|]
val b : Arr.arr =
  C0 C1 C2 C3  C4
R  1  2  1 -1 1.5

# let c = Owl_fft.D.rfft b
val c : (Complex.t, complex64_elt) Owl_dense_ndarray_generic.t =
         C0                  C1                   C2
R (4.5, 0i) (2.08156, -1.6511i) (-1.83156, 1.60822i)
</code></pre>
</div>
</section>
<section class="level3" id="n-d-discrete-fourier-transforms">
<h3>N-D Discrete Fourier transforms</h3>
<p>The owl FFT functions also applies to multi-dimensional arrays, such as matrix. Example: the fft matrix.</p>
<div class="highlight">
<pre><code class="language-text"># let a = Dense.Matrix.Z.eye 5
val a : Dense.Matrix.Z.mat =

        C0      C1      C2      C3      C4
R0 (1, 0i) (0, 0i) (0, 0i) (0, 0i) (0, 0i)
R1 (0, 0i) (1, 0i) (0, 0i) (0, 0i) (0, 0i)
R2 (0, 0i) (0, 0i) (1, 0i) (0, 0i) (0, 0i)
R3 (0, 0i) (0, 0i) (0, 0i) (1, 0i) (0, 0i)
R4 (0, 0i) (0, 0i) (0, 0i) (0, 0i) (1, 0i)

# let b = Owl_fft.D.fft a
val b : (Complex.t, complex64_elt) Owl_dense_ndarray_generic.t =

        C0                      C1                      C2                      C3                      C4
R0 (1, 0i)                 (1, 0i)                 (1, 0i)                 (1, 0i)                 (1, 0i)
R1 (1, 0i)  (0.309017, -0.951057i) (-0.809017, -0.587785i)  (-0.809017, 0.587785i)   (0.309017, 0.951057i)
R2 (1, 0i) (-0.809017, -0.587785i)   (0.309017, 0.951057i)  (0.309017, -0.951057i)  (-0.809017, 0.587785i)
R3 (1, 0i)  (-0.809017, 0.587785i)  (0.309017, -0.951057i)   (0.309017, 0.951057i) (-0.809017, -0.587785i)
R4 (1, 0i)   (0.309017, 0.951057i)  (-0.809017, 0.587785i) (-0.809017, -0.587785i)  (0.309017, -0.951057i)
</code></pre>
</div>
<p>IMAGE: plot x and y in to circle-like shape</p>
</section>
</section>
<section class="level2" id="applications-of-using-fft">
<h2>Applications of using FFT</h2>
<p>REFER: <em>Numerical in Matlab</em> book.</p>
<p>Unlike the regression chapter, <strong>make sure these examples work first</strong>, then perhaps fill in some content. They don’t have to be all finished for this round. But you have to be sure about the workload. Do not dig deep into the topic FFT. That takes a whole book and more.</p>
<section class="level3" id="find-period-of-sunspots">
<h3>Find period of sunspots</h3>
<p>Build data from a <a href="http://sidc.oma.be/silso/newdataset">dataset</a> from the Solar Influences Data Center. Explain the background of dataset, meaning of Wolfer index, and the dataset itself.</p>
<p>IMAGE: visualise the dataset.</p>
<p>We can see there is a cycle. We want to know how long it is.</p>
<div class="highlight">
<pre><code class="language-clike">CODE</code></pre>
</div>
<p>IMAGE: absolute fft’ed result vs.&nbsp;cycles per year. (periodogram)</p>
<p>Change x-axis into years per cycle</p>
<p>IMAGE</p>
<p>and we can see 11 years is a prominent cycle.</p>
</section>
<section class="level3" id="decipher-the-tone">
<h3>Decipher the Tone</h3>
</section>
<section class="level3" id="image-processing">
<h3>Image Processing</h3>
<p>(from scipy book; NR chap 12.6; or the data-driven book; or from the elegant scipy book)</p>
</section>
</section>
<section class="level2" id="b-splines">
<h2>B-Splines</h2>
</section>
<section class="level2" id="filtering">
<h2>Filtering</h2>
</section>
<section class="level2" id="kalman-filtering">
<h2>Kalman Filtering</h2>
</section>
<section class="level2 unnumbered" id="references">
<h2 class="unnumbered">References</h2>
<div role="doc-bibliography" class="references hanging-indent" id="refs">
<div id="ref-phillips2003signals">
<p>Phillips, Charles L, John M Parr, and Eve A Riskin. 2003. <em>Signals, Systems, and Transforms</em>. Prentice Hall Upper Saddle River.</p>
</div>
</div>
</section>
</section>
</article></div><a href="algodiff.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 11</small>Algorithmic Differentiation</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz">ocaml.xyz</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>Copyright 2017-2020 Liang Wang.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>