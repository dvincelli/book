<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="OCaml Scientific and Engineering Computing - Tutorial Book" name="description"><meta content="OCaml, Data Science, Data Analytics, Analytics, Functional Programming, Machine Learning, Deep Neural Network, Scientific Computing, Numerical Algorithm, Tutorial, Linear Algebra, Matrix" name="keywords"><meta content="Liang Wang" name="author"><title>Ordinary Differential Equations - OCaml Scientific Computing</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script><script data-ad-client="ca-pub-1868946892712371" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-123353217-1');</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing</h1><h5>1<sup>st</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.xyz/package/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="ordinary-differential-equations">
<h1>Ordinary Differential Equations</h1>
<section class="level2" id="what-is-an-ode">
<h2>What Is An ODE</h2>
<p>A <em>differential equation</em> is an equation that contains a function and one or more of its derivatives. It is studied ever since the invention of calculus, driven by the applications in mechanics, astronomy, and geometry. Currently it has become a important branch of mathematics study and its application is widely extended to biology, engineering, economics, and much more fields.</p>
<p>In a differential equation, if the function and its derivatives are about only one variable, we call it an <em>Ordinary Differential Equation</em>(ODE). It is often used to model one-dimensional dynamical systems. Otherwise it is an <em>Partial Differential Equation</em>(PDE). In this chapter we focus on the former one.</p>
<p>Generally, a ODE can be expressed as:</p>
<p><span id="eq:diffequation:ode-def"><span class="math display">\[ F(x, y^{'}, y^{''}, \ldots, y^{(n)}) = 0.\qquad(1)\]</span></span></p>
<p>The differential equations model dynamic systems, and the initial status of the system is often known. That is called <em>initial values</em>. They can be represented as:</p>
<p><span id="eq:diffequation:init"><span class="math display">\[y|_{x=x_0} = y_0, y^{'}|_{x=x_1} = y_1, \ldots ,\qquad(2)\]</span></span></p>
<p>where the <span class="math inline">\(y_0\)</span>, <span class="math inline">\(y_1\)</span>, etc. are known. The highest order of derivatives that are used in eq.&nbsp;1 is the <em>order</em> of this differential equation. A first-order differential equation can be generally expressed as: <span class="math inline">\(\frac{dy}{dx}=f(x,y)\)</span>, where <span class="math inline">\(f\)</span> is any function that contains <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. Solving eq.&nbsp;1 that fits given initial values as in eq.&nbsp;2 is called the <em>initial value problem</em>. Solving this kind of problems is the main target of many numerical ODE solvers.</p>
<section class="level3" id="exact-solutions">
<h3>Exact Solutions</h3>
<p>Solving a differential equation is often complex, but we do know how to solve part of them. Before looking at the the computer solvers to a random ODEs, let’s turn to the math first and look at some ODE forms that we already have analytical close-form solution to.</p>
<div id="tbl:diffequation:ode_solution">
<table>
<caption>Table 1: Examples of solutions to certain types of ODE</caption>
<colgroup>
<col style="width: 28%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">ODE</th>
<th style="text-align: left;">Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(P(y)\frac{dy}{dx} + Q(x) = 0\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\int^{y}P(y)dy + \int^{x}Q(x)dx = C\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\frac{dy}{dx} + P(x)y = Q(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(y=e^{-\sum_{x_0}^xP(x)dx}(y_0 + \sum_{x_0}^xQ(x)e^{\sum_{x_0}^xP(x)dx}dx)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The tbl.&nbsp;1 shows two examples. The first line is a type of ODEs that are called the “separable equations”. The second line represents the ODEs that are called the “linear first-order equations”. The solution to both form of ODE are already well-known, as shown in the second column. Here <span class="math inline">\(C\)</span> is a constant decided by initial condition <span class="math inline">\(x_0\)</span> and <span class="math inline">\(y_0\)</span>.</p>
<p>Note that in both types the derivative <span class="math inline">\(dy/dx\)</span> can be expressed explicitly as a function of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, and therefore is called <em>explicit</em> ODE. Otherwise it is called an <em>implicit</em> ODE.</p>
<p>High order ODEs can be reduced to the first order ones that contains only <span class="math inline">\(y'\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(x\)</span>. For example, an ODE in the form <span class="math inline">\(y^{(n)} = f(x)\)</span> can be reduced by multiple integrations one both sizes. If a two-order ODE is in the form <span class="math inline">\(y^{''} = f(x, y')\)</span>, let <span class="math inline">\(y' = g(x)\)</span>, then <span class="math inline">\(y^{''} = p'(x)\)</span>. Put them into the original ODE, it can be transformed as: <span class="math inline">\(p'=f(x,p)\)</span>. This is a first-order ODE that can be solved by normal solutions. Suppose we get <span class="math inline">\(y'=p=h(x, C_0)\)</span>, then this explicit form of ODE can be integrated to get: <span class="math inline">\(y = \int~h(x, C_0)dx + C_1\)</span>.</p>
<p>We have only scratch the surface of the ODE as traditional mathematics topic. This chapter does not aim to fully introduce how to solve ODEs analytically or simplify high-order ODEs. For those who interested, please refer to classical calculus books or courses.</p>
<p>(TODO: Explicit vs Implicit etc.: The three types of equations. This is important.)</p>
</section>
<section class="level3" id="linear-systems">
<h3>Linear Systems</h3>
<p>ODEs are often used to describe various dynamic systems. In the previous examples there is only one function <code>y</code> that changes over time. However, a real world system often contains multiple interdependent components, each can be described by a unique function that evolves over time. In the next of this chapter, we will talk about several ODE examples in detail, such as the two-body problem and the Lorenz attractor. For now, it suffices for us to look at eq.&nbsp;10 and eq.&nbsp;11 in the sections below and see how they are different from the single-variant ODE so far. For example, the Lorenz attractor system has three components that changes with time: the rate of convection in the atmospheric flow, the horizontal and vertical temperature variation.</p>
<p>These two systems are examples of what is called the <em>first-order linear system of ODE</em> or just the <em>linear system of ODE</em>. Generally, if we have:</p>
<p><span class="math display">\[\boldsymbol{y}(t) = \left[\begin{matrix}y_1(t) \\ \vdots \\ y_n(t) \end{matrix} \right],
\boldsymbol{A}(t) = \left[\begin{matrix}a_{11}(t) &amp; \ldots &amp; a_{1n}(t) \\ \vdots &amp; \ldots &amp; \vdots \\ a_{n1}(t) &amp; \ldots &amp; a_{nn}(t) \end{matrix} \right],
\textrm{and}
\boldsymbol{g}(t) = \left[\begin{matrix}g_1(t) \\ \vdots \\ g_n(t) \end{matrix} \right],
\]</span></p>
<p>then a linear system can be expressed as:</p>
<p><span id="eq:diffequation:linear-system"><span class="math display">\[\boldsymbol{y'}(t) = \boldsymbol{A}(t)\boldsymbol{y}(t) + \boldsymbol{g}(t).\qquad(3)\]</span></span></p>
<p>This linear system contains <span class="math inline">\(n\)</span> time-dependent components: <span class="math inline">\(y_1(t), y_2(t), \ldots, y_n(t)\)</span>. As we will be shown soon, the first-order linear system is especially suitable for the numerical ODE solver to solve. Therefore, transforming a high-order single-component ODE into a linear system is sometimes necessary, as we will show in the two body problem example. But before we stride too far away, let’s get back to the ground and start with the basics of solving an ODE numerically.</p>
</section>
</section>
<section class="level2" id="solving-an-ode-numerically">
<h2>Solving An ODE Numerically</h2>
<p>This section introduces the basic idea of solving the initial value problem numerically. Let’s start with an example:</p>
<p><span id="eq:diffequation:example01"><span class="math display">\[y' = 2xy + x,\qquad(4)\]</span></span></p>
<p>where the initial value is <span class="math inline">\(y(0) = 0\)</span>. Without going deep into the whole math calculation process (hint: it’s a separable first-order ODE), we give its analytical close-form solution:</p>
<p><span id="eq:diffequation:example01_solution"><span class="math display">\[y = 0.5(\exp{x^2} - 1).\qquad(5)\]</span></span></p>
<p>Now, pretending we don’t know the solution in eq.&nbsp;5, and we want to answer the question: what is <span class="math inline">\(y\)</span>’s value when <span class="math inline">\(x = 1\)</span> (or any other value)? How can we solve it numerically?</p>
<p>Meet the <em>Euler Method</em>, a first-order numerical procedure to solve initial value problems. This method proposes to approximate the function <span class="math inline">\(y\)</span> using a sequence of iterative steps:</p>
<p><span class="math display">\[ y_{n+1} = y_n + \Delta~f(x_n, y_n),\]</span></p>
<p>where <span class="math inline">\(\Delta\)</span> is a certain step size. This method is really easy to be implemented in OCaml, as shown below.</p>
<div class="highlight">
<pre><code class="language-ocaml">let x = ref 0.
let y = ref 0.
let target = 1.
let step = 0.001
let f x y = 2. *. x *. y +. x

let _ =
  while !x &lt;= target do
    y := !y +. step *. (f !x !y);
    x := !x +. step
  done</code></pre>
</div>
<p>In this case, we know that the analytical solution at <span class="math inline">\(x=1\)</span> is <span class="math inline">\(0.5(\exp{1^2} - 1\)</span>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">(Owl_const.e -. 1.)/. 2.;;
&gt;- : float = 0.859140914229522545
</code></pre>
</div>
<p>and the solution given by the previous numerical code is about <code>0.8591862</code>, which is pretty close to the true answer.</p>
<p>However, this method is as easy as it is unsuitable to be used in practical applications. One reason is that this method is not very accurate, despite that it works well in our example here. We will show this point soon. Also, it is not very stable, nor does it provide error estimate.</p>
<p>Therefore, we can modify the Euler’s method to use a “midpoint” in stepping, hoping to curb the error in the update process:</p>
<p><span class="math display">\[ s_1 = f(x_n, y_n),\]</span> <span id="eq:diffequation:rk2"><span class="math display">\[ s_2 = f(x_n + \Delta~/2, y_n + s_1~\Delta~/2),\qquad(6)\]</span></span> <span class="math display">\[ y_{n+1} = y_n + \Delta~\frac{s_1 + s_2}{2}.\]</span></p>
<p>This method is called the <em>Midpoint Method</em>, and we can also implement it in OCaml similarly. Let’s compare the performance of Euler and Midpoint in approximating the true result in eq.&nbsp;5:</p>
<div class="highlight">
<pre><code class="language-ocaml">let f x y = 2. *. x *. y +. x
let f' x = 0.5 *. (Maths.exp (x *. x) -. 1.)

let euler step target =
    let x = ref 0. in
    let y = ref 0. in
    while !x &lt;= target do
        y := !y +. step *. (f !x !y);
        x := !x +. step
    done;
    !y

let midpoint step target =
    let x = ref 0. in
    let y = ref 0. in
    while !x &lt;= target do
        let s1 = f !x !y in
        let s2 = f (!x +. step /. 2.) (!y +. step /. 2. *. s1) in
        y := !y +. step *. (s1 +. s2) /. 2.;
        x := !x +. step
    done;
    !y

let _ =
    let target = 2.6 in
    let h = Plot.create "plot_rk01.png" in
    Plot.(plot_fun ~h ~spec:[ RGB (66,133,244); LineStyle 1; LineWidth 2.; Marker "*" ] f' 2. target);
    Plot.(plot_fun ~h ~spec:[ RGB (219,68,55); LineStyle 2; LineWidth 2.; Marker "+" ] (euler 0.01) 2. target);
    Plot.(plot_fun ~h ~spec:[ RGB (219,68,55); LineStyle 2; LineWidth 2.; Marker "." ] (euler 0.001) 2. target);
    Plot.(plot_fun ~h ~spec:[ RGB (244,180,0); LineStyle 3; LineWidth 2.; Marker "+" ] (midpoint 0.01) 2. target);
    Plot.(plot_fun ~h ~spec:[ RGB (244,180,0); LineStyle 3; LineWidth 2.; Marker "." ] (midpoint 0.001) 2. target);
    Plot.(legend_on h ~position:NorthWest [|"Close-Form Solution"; "Euler (step = 0.01)";
        "Euler (step = 0.001)"; "Midpoint (step = 0.01)"; "Midpoint (step = 0.001)"|]);
    Plot.output h</code></pre>
</div>
<p>Let’s see the result.</p>
<figure>
<img alt="" style="width:80.0%" id="fig:diffequation:plot_rk01" title="plot_rk01" src="images/diffequation/plot_rk01.png"><figcaption>Figure 1: Comparing the accuracy of Euler method and Midpoint method in approximating solution to ODE</figcaption>
</figure>
<p>We can see that the choice of step size indeed matters to the precision. We use 0.01 and 0.001 for step size in the test, and for both cases the midpoint method outperforms the simple Euler method.</p>
<p>Should we stop now? Do we find a perfect solution in midpoint method? Surely no! We can follow the existing trend and add more intermediate stages in the update sequence. For example, we can do this:</p>
<p><span class="math display">\[ s_1 = f(x_n, y_n),\]</span> <span class="math display">\[ s_2 = f(x_n + \Delta~/2, y_n + s_1~\Delta~/2),\]</span> <span id="eq:diffequation:rk4"><span class="math display">\[ s_3 = f(x_n + \Delta~/2, y_n + s_2~\Delta~/2),\qquad(7)\]</span></span> <span class="math display">\[ s_4 = f(x_n + \Delta, y_n + s_3~\Delta),\]</span> <span class="math display">\[ y_{n+1} = y_n + \Delta~\frac{s_1 + 2s_2+2s_3+s_4}{6}.\]</span></p>
<p>Here in each iteration four intermediate steps are computed, once at the initial point, once at the end, and twice at the midpoints. This method often more accurate than the midpoint method.</p>
<p>We won’t keep going on but you have seen the pattern. These seemingly mystical parameters are related to the term in Taylor series expansions. In the previous methods, e.g.&nbsp;Euler method, every time you update <span class="math inline">\(y_n\)</span> to <span class="math inline">\(y_{n+1}\)</span>, an error is introduced into the approximation. The <em>order</em> of a method is the exponent of the smallest power of <span class="math inline">\(\Delta\)</span> that cannot be matched. All these methods are called <em>Runge-Kutta Method</em>. It’s basic idea is to remove the errors order by order, using the correct set of coefficients. A higher order of error indicates smaller error.</p>
<p>The Euler is the most basic form of Runge-Kutta method, and the Midpoint is also called the second-order Runge-Kutta Method (rk2). What eq.&nbsp;7 shows is a fourth-order Runge-Kutta method (rk4). It is the most often used RK method and works surprisingly well in many cases, and it is often a good choice especially when computing <span class="math inline">\(f\)</span> is not expensive.</p>
<p>However, as powerful as it may be, the classical <code>rk4</code> is still a native implementation, and a modern ODE solvers, though largely follows the same idea, adds more “ingredients”. For example, the step size should be adaptively updated instead of being const in our example. Also, you may have seen solvers with names such as <code>ode45</code> in MATLAB, and in their implementation, it means that this solver gets its error estimate at each step by comparing the 4th order solution and 5th order solution and then decide the direction.</p>
<p>Besides, other methods also exists. For example, the Bulirsch-Stoer method is known to be both accurate and and efficient computation-wise. (TODO: Brief introduction of Adam and BDF.) Discussion of these advanced numerical methods and techniques are beyond this book. Please refer to <span data-cites="press2007numerical" class="citation">(Press et al. 2007)</span> for more information.</p>
</section>
<section class="level2" id="owl-ode">
<h2>Owl-ODE</h2>
<p>Obviously, we cannot just relies on these manual solutions every time in practical use. It’s time we use some tools. Based on the computation functionalities and ndarray data structures in Owl, we provide the package “<a href="https://github.com/owlbarn/owl_ode">owl_ode</a>” to perform the tasks of solving the initial value problems. Without further due, let’s see it how the <code>owl-ode</code> package can be used to solve ODE problem.</p>
<section class="level3" id="example-linear-oscillator-system">
<h3>Example: Linear Oscillator System</h3>
<p>EXPLAIN: how the equation of Oscillator becomes this linear representation.</p>
<p>This oscillation system appears frequently in Physics and several other fields: charge flow in electric circuit, sound wave, light wave, etc. These phenomena all follow the similar pattern of ODEs. One example is the mass on a spring.</p>
<p>Let’s see how to solve a time independent linear dynamic system that contains two states:</p>
<p><span id="eq:diffequation:example_01"><span class="math display">\[\frac{dy}{dt} = Ay, \textrm{where } A = \left[ \begin{matrix} 1 &amp; -1 \\ 2 &amp; -3 \end{matrix} \right].\qquad(8)\]</span></span></p>
<p>This equation represents an oscillator system. In this system, <span class="math inline">\(y\)</span> is the state of the system, and <span class="math inline">\(t\)</span> is time. The initial state at <span class="math inline">\(t=0\)</span> is <span class="math inline">\(y_0 = \left[ -1, 1\right]^T\)</span>. Now we want to know the system state at <span class="math inline">\(t=2\)</span>. The function can be expressed in Owl using the matrix module.</p>
<div class="highlight">
<pre><code class="language-ocaml">let f y t =
  let a = [|[|1.; -1.|];[|2.; -3.|]|]|&gt; Mat.of_arrays in
  Mat.(a *@ y)</code></pre>
</div>
<p>Next, we want to specify the timespan of this problem: from 0 to 2, at a step of 0.001.</p>
<div class="highlight">
<pre><code class="language-clike">let tspec = Owl_ode.Types.(T1 {t0 = 0.; duration = 2.; dt=1E-3})</code></pre>
</div>
<p>One last thing to solve the problem is of course the initial values:</p>
<div class="highlight">
<pre><code class="language-ocaml">let x0 = Mat.of_array [|-1.; 1.|] 2 1</code></pre>
</div>
<p>And finally we can provide all these information to the <code>rk4</code> solver in <code>Owl_ode</code> and get the answer:</p>
<div class="highlight">
<pre><code class="language-clike">let ts, ys = Owl_ode.Ode.odeint Owl_ode.Native.D.rk4 f x0 tspec ()

val ts : Owl_dense_matrix_d.mat =

   C0    C1    C2    C3    C4     C1996 C1997 C1998 C1999 C2000
R0  0 0.001 0.002 0.003 0.004 ... 1.996 1.997 1.998 1.999     2

val ys : Owl_dense_matrix_d.mat =

   C0       C1       C2       C3       C4        C1996    C1997    C1998    C1999    C2000
R0 -1   -1.002 -1.00399 -1.00599 -1.00798 ... -3.56302 -3.56451   -3.566 -3.56749 -3.56898
R1  1 0.995005 0.990022 0.985049 0.980088 ... -2.07436 -2.07527 -2.07617 -2.07707 -2.07798</code></pre>
</div>
<p>The <code>rk4</code> solver is short for “forth-order Runge-Kutta Method” that we have introduced before. The results shows both the steps <span class="math inline">\(ts\)</span> and the system values at each step <span class="math inline">\(ys\)</span>. We can visualise the oscillation according to the result:</p>
<figure>
<img alt="" style="width:60.0%" id="fig:diffequation:plot_rk00" title="plot_rk00" src="images/diffequation/plot_rk00.png"><figcaption>Figure 2: Visualise the solution of a simple linear system</figcaption>
</figure>
</section>
<section class="level3" id="solver-structure">
<h3>Solver Structure</h3>
<p>Hope that you have gotten the gist of how to use <code>Owl-ode</code>. From these example, we can see that the <code>owl-ode</code> abstracts the initial value problems as four different parts:</p>
<ol type="1">
<li>a function <span class="math inline">\(f\)</span> to shows how the system evolves in equation <span class="math inline">\(y'(t) = f(y, t)\)</span>;</li>
<li>a specification of the timespan;</li>
<li>system initial values;</li>
<li>and most importantly, a solver.</li>
</ol>
<p>If you look at the signature of a solver:</p>
<div class="highlight">
<pre><code class="language-clike">val rk4 : (module Types.Solver
    with type state = M.arr
    and type f = M.arr -&gt; float -&gt; M.arr
    and type step_output = M.arr * float
    and type solve_output = M.arr * M.arr)</code></pre>
</div>
<p>it clear indicates these different parts. Based on this uniform abstraction, you can choose a suitable solver and use it to solve many complex and practical ODE problems. Note that due to the difference of solvers, the requirement of different solver varies. Some requires the state to be two matrices, while others process data in a more general ndarray format.</p>
</section>
<section class="level3" id="features-and-limits">
<h3>Features and Limits</h3>
<p>TODO: <em>EXPLAIN what is symplectic solver and how it can be fit into existing framework</em>.</p>
<p><code>Owl-ode</code> provides a wide range to solvers. It implements native solvers and symplectic solvers which are based on the step-by-step update basic idea we have discussed. Currently there are already many mature off-the-shelf tools for solving ODEs, we choose two of them: <a href="(https://computing.llnl.gov/projects/sundials),">sundials</a> and <a href="https://computing.llnl.gov/casc/odepack/">ODEPACK</a>. Both methods are well implemented and widely used in practical use. (TODO: more information.)</p>
<ul>
<li><p><code>sundials</code>: a SUite of Nonlinear and DIfferential/ALgebraic equation Solvers. It contains six solvers, and we interface to its <code>CVODE</code> solver for solving initial value problems for ordinary differential equation systems.</p></li>
<li><p><code>odepack</code>: ODEPACK is a collection of Fortran solvers for the initial value problem for ordinary differential equation systems. We interface to its LSODA solver which is for solving the explicit form ODE.</p></li>
</ul>
<p>For all these solvers, <code>owl-ode</code> provides an easy-to-use unified interface, as you have seen in the examples. tbl.&nbsp;2 is a table that lists all the solvers that are currently supported by <code>owl-ode</code>.</p>
<div id="tbl:diffequation:solvers">
<table>
<caption>Table 2: Solvers provided by owl-ode and their types.</caption>
<thead>
<tr class="header">
<th>Solvers</th>
<th>Type</th>
<th>State</th>
<th>Function</th>
<th>Step</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>rk4</code></td>
<td>Native</td>
<td><code>M.arr</code></td>
<td><code>M.arr -&gt; float -&gt; M.arr</code></td>
<td><code>M.arr * float</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>rk23</code></td>
<td>Native</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>rk45</code></td>
<td>Native</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Euler</td>
<td>Native</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Midpoint</td>
<td>Native</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Cvode</td>
<td>Sundials</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Cvode_stiff</td>
<td>Sundials</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>LSODA</td>
<td>ODEPACK</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>TODO: add more solvers <strong>Automatic inference of state dimensionality</strong></p>
<p>(COPY ALERT)</p>
<p>All the provided solvers automatically infer the dimensionality of the state from the initial state. Consider the Native solvers, for which the state of the system is a matrix. The initial state can be a row vector, a column vector, or a matrix, so long as it is consistent with that of <span class="math inline">\(f\)</span>. If the initial state <span class="math inline">\(y_0\)</span> is a row vector with dimensions 1xN and we integrate the system for <span class="math inline">\(T\)</span> time steps, the time and states will be stacked vertically in the output (i.e.&nbsp;<code>ts</code> will have dimensions <code>Tx1</code> and and <code>ys</code> will have dimensions <code>TxN</code>). On the contrary, if the initial state %y_0$ is a column vector with dimensions, the results will be stacked horizontally (i.e.&nbsp;<span class="math inline">\(ts\)</span> will have dimensions <code>1xT</code> and <span class="math inline">\(ys\)</span> will have dimensions <code>NxT</code>).</p>
<p>We also support temporal integration of matrices. That is, cases in which the state <span class="math inline">\(y\)</span> is a matrix of dimensions of dimensions <code>NxM</code>. By default, in the output, we flatten and stack the states vertically (i.e., ts has dimensions Tx1 and xs has dimensions TxNM. We have a helper function <code>Native.D.to_state_array</code> which can be used to pack <span class="math inline">\(ys\)</span> into an array of matrices.</p>
<p><strong>Custom Solvers</strong></p>
<p>We can define new solver module by creating a module of type Solver. For example, to create a custom Cvode solver that has a relative tolerance of 1E-7 as opposed to the default 1E-4, we can define and use <code>custom_cvode</code> as follows:</p>
<div class="highlight">
<pre><code class="language-clike">let custom_cvode = Owl_ode_sundials.cvode ~stiff:false ~relative_tol:1E-7 ~abs_tol:1E-4
(* usage *)
let ts, xs = Owl_ode.Ode.odeint custom_cvode f x0 tspec ()</code></pre>
</div>
<p>Here, we use the <code>cvode</code> function construct a solver module <code>Custom_Owl_Cvode</code>. Similar helper functions like cvode have been also defined for native and symplectic solvers.</p>
<p><strong>Multiple Backends</strong></p>
<p>The owl-ode-base contains implementations that are purely written in OCaml. As such, they are compatible for use in Mirage OS or in conjunction with js_of_ocaml, where C library linking is not supported.</p>
<p><strong>Limit</strong></p>
<p>Note that currently the <code>owl-ode</code> is still at development phase. Due to lack of vector-valued root finding functions, it is limited to solving initial value problems for the explicit ODE of form <span class="math inline">\(y' = f(y, x)\)</span>.</p>
</section>
</section>
<section class="level2" id="examples-of-using-owl-ode">
<h2>Examples of using Owl-ODE</h2>
<p>As with many good things in the world, Mastering solving ODE requires practice. After getting to know <code>owl-ode</code> in the previous section, in this section we will demonstrate more examples of using this tool.</p>
<section class="level3" id="explicit-ode">
<h3>Explicit ODE</h3>
<p>Now that we have this powerful tool, we can use the solver in <code>owl-ode</code> to solve the motivative problem in eq.&nbsp;4 with simple code.</p>
<div class="highlight">
<pre><code class="language-clike">let f y t = Mat.(2. $* y *$ t +$ t)

let tspec = Owl_ode.Types.(T1 {t0 = 0.; duration = 1.; dt=1E-3})

let y0 = Mat.zeros 1 1

let solver = Owl_ode.Native.D.rk45 ~tol:1E-9 ~dtmax:10.0

let _, ys = Owl_ode.Ode.odeint solver f y0 tspec ()</code></pre>
</div>
<p>The code is mostly similar to previous example, the only difference is that we can now try another solver provided: the <code>rk45</code> solver, with certain parameters specified. You don’t have to worry about what the <code>tol</code> or <code>dtmax</code> means for now. Note that this solver (and the previous one) requires input to be of type <code>mat</code> in Owl, and the function <span class="math inline">\(f\)</span> be of type <code>mat -&gt; float -&gt; mat</code>. The result is as expected:</p>
<div class="highlight">
<pre><code class="language-clike"># Mat.transpose ys
- : Mat.mat =

   C0    C1          C2          C3          C4        C996    C997    C998    C999   C1000
R0  0 1E-06 4.00001E-06 9.00004E-06 1.60001E-05 ... 1.69667 1.70205 1.70744 1.71285 1.71828</code></pre>
</div>
<p>(TODO: the result is not as expected from eq.&nbsp;5 and previous manual solution. Find the reason)</p>
</section>
<section class="level3" id="damped-oscillation">
<h3>Damped Oscillation</h3>
<p>(TODO: check if the section title is suitable)</p>
<p>TODO: explain the problem; explain why the symplectic solver is used.</p>
<div class="highlight">
<pre><code class="language-clike">let damped_noforcing a (xs, ps) _ : Owl.Mat.mat =
  Owl.Mat.((xs *$ -1.0) + (ps *$ (-1.0 *. a)))


let a = 1.0
let dt = 0.1

let plot_sol fname t sol1 sol2 sol3 =
  let open Owl in
  let h = Plot.create fname in
  let open Plot in
  set_foreground_color h 0 0 0;
  set_background_color h 255 255 255;
  set_title h fname;
  plot ~h ~spec:[ RGB (0, 0, 255); LineStyle 1 ] t (Mat.col sol1 0);
  plot ~h ~spec:[ RGB (0, 255, 0); LineStyle 1 ] t (Mat.col sol2 0);
  plot ~h ~spec:[ RGB (255, 0, 0); LineStyle 1 ] t (Mat.col sol3 0);
  legend_on h ~position:NorthEast [| "Leapfrog"; "Ruth3"; "Symplectic Euler" |];
  output h


let () =
  let x0 = Owl.Mat.of_array [| -0.25 |] 1 1 in
  let p0 = Owl.Mat.of_array [| 0.75 |] 1 1 in
  let t0, duration = 0.0, 15.0 in
  let f = damped_noforcing a in
  let tspec = T1 { t0; duration; dt } in
  let t, sol1, _ = Ode.odeint (module Symplectic.D.Leapfrog) f (x0, p0) tspec () in
  let _, sol2, _ = Ode.odeint Symplectic.D.ruth3 f (x0, p0) tspec () in
  let _, sol3, _ =
    Ode.odeint (module Symplectic.D.Symplectic_Euler) f (x0, p0) tspec ()
  in
  plot_sol "damped.png" t sol1 sol2 sol3</code></pre>
</div>
<p>IMAGE</p>
</section>
<section class="level3" id="two-body-problem">
<h3>Two Body Problem</h3>
<p>In classical mechanics, the <em>two-body problem</em> is to predict the motion of two massive objects. It is assumed that the only force that are considered comes from each other, and both objects are not affected by any other object. This problem can be seen in the astrodynamics where the objects of interests are planets, satellites, etc. under the influence of only gravitation. Another case is the trajectory of electron around Atomic nucleus in a atom.</p>
<p>This classic problem is one of the earliest investigated mechanics problems, and was long solved from the age of Newton. It is also a typical integrable problem in classical mechanics. In this example, let’s consider a simplified version of this problem. We assume that the two objects interact on a 2-dimensional plane, and one of them is so much more massive than the other one that it can be thought of as being static (think about electron and nucleus) and sits at the zero point of a Cartesian coordinate system (0, 0) in the plane. In this system, let’s consider the trajectory of the lighter object. This “one-body” problem is basis of the two body problem. For many forces, including gravitational ones, a two-body problem can be divided into a pair of one-body problems.</p>
<p>Given the previous assumption and newton’s equation, it can be <a href="https://people.sc.fsu.edu/~jburkardt/m_src/two_body_simulation/two_body_simulation.html">proved</a> that the location of the lighter object [<span class="math inline">\(y_0\)</span>, <span class="math inline">\(y_1\)</span>] with regard to time <span class="math inline">\(t\)</span> can be described by:</p>
<p><span class="math display">\[y_0^{''}(t) = -\frac{y_0}{r^3},\]</span> <span id="eq:diffequation:twobody"><span class="math display">\[y_1^{''}(t) = -\frac{y_1}{r^3},\qquad(9)\]</span></span></p>
<p>where <span class="math inline">\(r=\sqrt{y_0^2 + y_1^2}\)</span>. These are a second-order ODEs, and to make it solvable using our tool, we need to make them into a first-order explicit ordinary differential equation system:</p>
<p><span class="math display">\[y_0^{'} = y_2,\]</span> <span class="math display">\[y_1^{'} = y_3,\]</span> <span id="eq:diffequation:twobody_system"><span class="math display">\[y_2^{'} = -\frac{y_0}{r^3},\qquad(10)\]</span></span> <span class="math display">\[y_3^{'} = -\frac{y_1}{r^3},\]</span></p>
<p>Based on eq.&nbsp;10, we can build up our code as below:</p>
<div class="highlight">
<pre><code class="language-clike">let f y _t =
  let y = Mat.to_array y in
  let r = Maths.(sqrt ((sqr y.(0)) +. (sqr y.(1)))) in
  let y0' = y.(2) in
  let y1' = y.(3) in
  let y2' = -.y.(0) /. (Maths.pow r 3.) in
  let y3' = -.y.(1) /. (Maths.pow r 3.) in
  [| [|y0'; y1'; y2'; y3'|] |] |&gt; Mat.of_arrays

let y0 = Mat.of_array [|-1.; 0.; 0.5; 0.5|] 1 4
let tspec = Owl_ode.Types.(T1 {t0 = 0.; duration = 20.; dt=1E-2})
let custom_solver = Native.D.rk45 ~tol:1E-9 ~dtmax:10.0</code></pre>
</div>
<p>Here the <code>y0</code> provides initial status of the system: first two numbers denote the initial location of object, and the next two numbers indicate the initial momentum to this object. (TODO: check if this is true or a better word should be used.) After building the function, initial status, timespan, and solver, we can then solve the system and visualise it.</p>
<div class="highlight">
<pre><code class="language-clike">let _ =
  let ts, ys = Ode.odeint custom_solver f y0 tspec () in
  let h = Plot.create "two_body.png" in
  let open Plot in
  plot ~h ~spec:[ RGB (66, 133, 244); LineStyle 1 ] (Mat.col ys 0) (Mat.col ys 1);
  scatter ~h ~spec:[ Marker "#[0x229a]"; MarkerSize 5. ] (Mat.zeros 1 1) (Mat.zeros 1 1);
  text ~h ~spec:[ RGB (51,51,51)] (-.0.3) 0. "Massive Object";
  output h</code></pre>
</div>
<figure>
<img alt="" style="width:80.0%" id="fig:diffequation:two-body" title="two-body" src="images/diffequation/two-body.png"><figcaption>Figure 3: The trajectory of lighter object orbiting the massive object in a simplified two-body problem</figcaption>
</figure>
<p>One example of this simplified two-body problem is the “planet-sun” system where a planet orbits the sun. Kepler’s law states that in this system the planet goes around the sun in an ellipse shape, with the sun at a focus of the ellipse. The orbiting trajectory in the result visually follows this theory.</p>
</section>
<section class="level3" id="lorenz-attractor">
<h3>Lorenz Attractor</h3>
<p>Lorenz equations are one of the most thoroughly studied ODEs. This system of ODEs is proposed by Edward Lorenz in 1963 to model flow of fluid (the air in particular) from hot area to cold area. Lorenz simplified the numerous atmosphere factors into the simple equations below.</p>
<p><span class="math display">\[x'(t) = \sigma~(y(t)- x(t))\]</span> <span id="eq:diffequation:lorenz"><span class="math display">\[y'(t) = x(t)(\rho - z(t)) - y(t)\qquad(11)\]</span></span> <span class="math display">\[z'(t) = x(t)y(t) - \beta~z(t)\]</span></p>
<p>Here <span class="math inline">\(x\)</span> is proportional to the rate of convection in the atmospheric flow, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> are proportional to the horizontal and vertical temperature variation. Parameter <span class="math inline">\(\sigma\)</span> is the Prandtl number, and <span class="math inline">\(\rho\)</span> is the normalised Rayleigh number. <span class="math inline">\(\beta\)</span> is related to the geometry of the domain. The most commonly used parameter values are: <span class="math inline">\(\sigma = 10, \rho=20\)</span>, and <span class="math inline">\(\beta = \frac{8}{3}\)</span>. Based on these information, we can use <code>owl-ode</code> to express the Lorenz equations with code.</p>
<div class="highlight">
<pre><code class="language-ocaml">let sigma = 10.
let beta = 8. /. 3.
let rho = 28.

let f y _t =
  let y = Mat.to_array y in
  let y0' = sigma *. (y.(1) -. y.(0)) in
  let y1' = y.(0) *. (rho -. y.(2)) -. y.(1) in
  let y2' = y.(0) *. y.(1) -. beta *. y.(2) in
  [| [|y0'; y1'; y2'|] |] |&gt; Mat.of_arrays</code></pre>
</div>
<p>We set the initial values of the system to <code>-1</code>, <code>-1</code>, and <code>1</code> respectively. The simulation timespan is set to 30 seconds, and keep using the <code>rk45</code> solver.</p>
<div class="highlight">
<pre><code class="language-clike">let y0 = Mat.of_array [|-1.; -1.; 1.|] 1 3
let tspec = Owl_ode.Types.(T1 {t0 = 0.; duration = 30.; dt=1E-2})
let custom_solver = Native.D.rk45 ~tol:1E-9 ~dtmax:10.0</code></pre>
</div>
<p>Now, we can solve the ODEs system and visualise the results. In the plots, we first show how the value of <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> changes with time; next we show the phase plane plots between each two of them.</p>
<div class="highlight">
<pre><code class="language-clike">let _ =
  let ts, ys = Ode.odeint custom_solver f y0 tspec () in
  let h = Plot.create ~m:2 ~n:2 "lorenz_01.png" in
  let open Plot in
  subplot h 0 0;
  set_xlabel h "time";
  set_ylabel h "value on three axes";
  plot ~h ~spec:[ RGB (66, 133, 244); LineStyle 1 ] ts (Mat.col ys 2);
  plot ~h ~spec:[ RGB (219, 68,  55); LineStyle 1 ] ts (Mat.col ys 1);
  plot ~h ~spec:[ RGB (244, 180,  0); LineStyle 1 ] ts (Mat.col ys 0);
  subplot h 0 1;
  set_xlabel h "x-axis";
  set_ylabel h "y-axis";
  plot ~h ~spec:[ RGB (66, 133, 244) ] (Mat.col ys 0) (Mat.col ys 1);
  subplot h 1 0;
  set_xlabel h "y-axis";
  set_ylabel h "z-axis";
  plot ~h ~spec:[ RGB (66, 133, 244) ] (Mat.col ys 1) (Mat.col ys 2);
  subplot h 1 1;
  set_xlabel h "x-axis";
  set_ylabel h "z-axis";
  plot ~h ~spec:[ RGB (66, 133, 244) ] (Mat.col ys 0) (Mat.col ys 2);
  output h</code></pre>
</div>
<figure>
<img alt="" style="width:100.0%" id="fig:diffequation:lorenz_01" title="lorenz_01" src="images/diffequation/lorenz_01.png"><figcaption>Figure 4: Three components and phase plane plots of Lorenz attractor</figcaption>
</figure>
<p>From fig.&nbsp;4, we can image that the status of system keep going towards two “voids” in a three dimensional space, jumping from one to the other. These two voids are a certain type of <em>attractors</em> in this dynamic system, where a system tends to evolve towards.</p>
<p>Now, about Lorenz equation, there is an interesting question: “what would happen if I change the initial value slightly?” For some systems, such as a pendulum, that wouldn’t make much a difference, but not here. We can see that clearly in Owl. Keep function and timespan the same, let’s change only 0.1% of initial value and then solve the system.</p>
<div class="highlight">
<pre><code class="language-clike">let y00 = Mat.of_array [|-1.; -1.; 1.|] 1 3
let y01 = Mat.of_array [|-1.001; -1.001; 1.001|] 1 3
let ts0, ys0 = Ode.odeint custom_solver f y00 tspec ()
let ts1, ys1 = Ode.odeint custom_solver f y01 tspec ()</code></pre>
</div>
<p>To make later calculation easier, we can make the two resulting matrices to be of the same shape using slicing.</p>
<div class="highlight">
<pre><code class="language-clike">let r0, c0 = Mat.shape ys0
let r1, c1 = Mat.shape ys1
let r  = if (r0 &lt; r1) then r0 else r1
let ts = if (r0 &lt; r1) then ts0 else ts1
let ys0 = Mat.get_slice [[0; r-1]; []] ys0
let ys1 = Mat.get_slice [[0; r-1]; []] ys1</code></pre>
</div>
<p>Now, we can compare the euclidean distance between the status of these two systems at certain time. Also, we shows the value change of three components with time after changing initial values.</p>
<div class="highlight">
<pre><code class="language-clike">let _ =
  (* plot the distance between two systems *)
  let h = Plot.create ~m:1 ~n:2 "lorenz_02.png" in
  let open Plot in
  subplot h 0 0;
  set_xlabel h "time";
  set_ylabel h "value on three axes";
  plot ~h ~spec:[ RGB (244, 180,  0); LineStyle 1 ] ts (Mat.col ys1 0);
  plot ~h ~spec:[ RGB (219, 68,  55); LineStyle 1 ] ts (Mat.col ys1 1);
  plot ~h ~spec:[ RGB (66, 133, 244); LineStyle 1 ] ts (Mat.col ys1 2);
  subplot h 0 1;
  let diff = Mat.(
    sqr ((col ys0 0) - (col ys1 0)) +
    sqr ((col ys0 1) - (col ys1 1)) +
    sqr ((col ys0 2) - (col ys1 2))
    |&gt; sqrt
  )
  in
  plot ~h ~spec:[ RGB (66, 133, 244); LineStyle 1 ] ts diff;
  set_xlabel h "time";
  set_ylabel h "distance of two systems";
  output h</code></pre>
</div>
<figure>
<img alt="" style="width:100.0%" id="fig:diffequation:lorenz_02" title="lorenz_02" src="images/diffequation/lorenz_02.png"><figcaption>Figure 5: Change the initial states on three dimension by only 0.1%, and the value of Lorenz system changes visibly.</figcaption>
</figure>
<p>According to fig.&nbsp;5, the first figure shows that, initially the systems looks quite like that in fig.&nbsp;4, but after about 15 seconds, the system state begins to change. This change is then quantified using the euclidean distance between these two systems. Clearly the difference two system changes sharply after a certain period of time, with no sign fo converge. You can try to extend the timespan longer, and the conclusion will still be similar.</p>
<p>This result shows that, in the Lorenz system, even a tiny bit of change in the initial state can lead to a large and chaotic change of future state after a while. It partly explains why weather prediction is difficult to do: you can only accurately predict the weather for a certain period of time, any day longer and the weather will be extremely sensitive to a tiny bit of perturbations at the beginning, such as …, well, such as the flapping of the wings of a distant butterfly several weeks earlier. You are right, the Lorenz equation is closely related to the idea we now call “butterfly effect” in the pop culture.</p>
</section>
</section>
<section class="level2" id="stiffness">
<h2>Stiffness</h2>
<p><em>Stiffness</em> is an important concept in the numerical solution of ODE. Think about a function that has a “cliff” where at a point its nearby value changes rapidly. Therefore, to find the solution with normal method as we have used, it may requires such a extremely small stepping size that traversing the whole timespan may takes a very long time and lot of computation.</p>
<p>TODO: the very basic idea of stiff algorithms.</p>
<p>The <strong>Van der Pol equation</strong> is a good example to show both non-stiff and stiff cases. In dynamics, the Van der Pol oscillator is a non-conservative oscillator with non-linear damping. Its behaviour with time can be described with a high order ODE:</p>
<p><span id="eq:diffequation:vanderpol_0"><span class="math display">\[y^{''} - \mu~(1-y^2)y' + y = 0,\qquad(12)\]</span></span></p>
<p>where <span class="math inline">\(\mu\)</span> is a scalar parameter indicating the non-linearity and the strength of the damping. To make it solvable using our tool, we can change it into a pair of explicit one-order ODEs in a linear system:</p>
<p><span class="math display">\[y_0^{'} = y_1,\]</span> <span id="eq:diffequation:vanderpol_1"><span class="math display">\[y_1^{'} = \mu~(1-y_0^2)y_1 - y_0.\qquad(13)\]</span></span></p>
<p>As we will show shortly, by varying the damping parameter, this group of equations can be either non-still or stiff.</p>
<p>We provide both stiff (<code>Owl_Cvode_Stiff</code>) and non-still (<code>Owl_Cvode</code>) solver by interfacing to Sundials, and the <code>LSODA</code> solver of ODEPACK can automatically switch between stiff and non-stiff algorithms. We will try both in the example.</p>
<p>Here we start with the basic function code that are shared by both cases.</p>
<div class="highlight">
<pre><code class="language-clike">open Owl
open Owl_ode
open Owl_ode.Types
open Owl_plplot

let van_der_pol mu =
  fun y _t -&gt;
    let y = Mat.to_array y in
    [| [| y.(1); mu *. (1. -. Maths.sqr y.(0)) *. y.(1) -.y.(0) |] |]
    |&gt; Mat.of_arrays</code></pre>
</div>
<section class="level3" id="solve-non-stiff-odes">
<h3>Solve Non-Stiff ODEs</h3>
<p>When set the parameter to 1, the equation is a normal non-stiff one, and let’s try to use the <code>Cvode</code> solver from sundials to do this job.</p>
<div class="highlight">
<pre><code class="language-clike">let f_non_stiff = van_der_pol 1.

let y0 = Mat.of_array [| 0.02; 0.03 |] 1 2

let tspec = T1 { t0 = 0.0; dt = 0.01; duration = 30.0 }

let ts, ys = Ode.odeint (module Owl_ode_sundials.Owl_Cvode) f_stiff y0 tspec ()</code></pre>
</div>
<p>Everything seems normal. To see the “non-stiffness” clearly, we can plot how the two system states change over time, and a phase plane plot of their trajectory on the plane, using the two states as x- and y-axis values. The result is shown in fig.&nbsp;6.</p>
<div class="highlight">
<pre><code class="language-clike">let () =
  let fname = "vdp_sundials_nonstiff.png" in
  let h = Plot.create ~n:2 ~m:1 fname in
  let open Plot in
  set_foreground_color h 0 0 0;
  set_background_color h 255 255 255;
  subplot h 0 0;
  plot ~h ~spec:[ RGB (0, 0, 255); LineStyle 1 ] (Mat.col ys 0) (Mat.col ys 1);
  subplot h 0 1;
  plot ~h ~spec:[ RGB (0, 0, 255); LineStyle 1 ] ts Mat.(col ys 1);
  plot ~h ~spec:[ RGB (0, 0, 255); LineStyle 3 ] ts Mat.(col ys 0);
  output h
</code></pre>
</div>
<figure>
<img alt="" style="width:100.0%" id="fig:diffequation:nonstiff" title="vdp_sundials_nonstiff" src="images/diffequation/vdp_sundials_nonstiff.png"><figcaption>Figure 6: Solving Non-Stiff Van der Pol equations with Sundial CVode solver</figcaption>
</figure>
</section>
<section class="level3" id="solve-stiff-odes">
<h3>Solve Stiff ODEs</h3>
<p>Change the parameters to 1000, and now this function becomes <em>stiff</em>. We follow the same procedure as before, but now we use the <code>Lsoda</code> solver from odepack, and the timespan is extended to 3000. From fig.&nbsp;7 we can see clearly what “stiff” means. Both lines in this figure contain very sharp “cliffs”.</p>
<div class="highlight">
<pre><code class="language-clike">let f_stiff = van_der_pol 1000.
let y0 = Mat.of_array [| 2.; 0. |] 1 2
let tspec = T1 { t0 = 0.0; dt = 0.01; duration = 3000.0 }

let () =
  let ts, ys = Ode.odeint (module Owl_ode_odepack.Lsoda) f_stiff y0 tspec () in
  let fname = "vdp_odepack_stiff.png" in
  let h = Plot.create fname in
  let open Plot in
  set_foreground_color h 0 0 0;
  set_background_color h 255 255 255;
  set_yrange h (-2.) 2.;
  plot ~h ~spec:[ RGB (0, 0, 255); LineStyle 1 ] ts Mat.(col ys 1);
  plot ~h ~spec:[ RGB (0, 0, 255); LineStyle 3 ] ts Mat.(col ys 0);
  output h
</code></pre>
</div>
<figure>
<img alt="" style="width:70.0%" id="fig:diffequation:stiff" title="vdp_odepack_stiff" src="images/diffequation/vdp_odepack_stiff.png"><figcaption>Figure 7: Solving Stiff Van der Pol equations with ODEPACK LSODA solver.</figcaption>
</figure>
</section>
</section>
<section class="level2" id="choose-ode-solvers">
<h2>Choose ODE solvers</h2>
<p>Question: “why cannot I just use a ‘best’ solver for all the questions?”</p>
<p>TODO: Introduce the basic principles of how to choose solvers</p>
</section>
<section class="level2" id="summary">
<h2>Summary</h2>
</section>
<section class="level2 unnumbered" id="references">
<h2 class="unnumbered">References</h2>
<div role="doc-bibliography" class="references hanging-indent" id="refs">
<div id="ref-press2007numerical">
<p>Press, William H, Saul A Teukolsky, William T Vetterling, and Brian P Flannery. 2007. <em>Numerical Recipes 3rd Edition: The Art of Scientific Computing</em>. Cambridge university press.</p>
</div>
</div>
</section>
</section>
</article></div><a href="signal.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 10</small>Signal Processing</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz">ocaml.xyz</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>Copyright 2017-2020 Liang Wang.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>