<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Architecture Overview - OCaml Scientific Computing</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing</h1><h5>1<sup>st</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.xyz/package/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="architecture-overview">
<h1>Architecture Overview</h1>
<p>Refer to <span data-cites="wang2017owl" class="citation">(Wang 2017)</span> <span data-cites="minsky2013real" class="citation">(Minsky, Madhavapeddy, and Hickey 2013)</span>, example of references</p>
<p>Owl is an emerging library developed in the OCaml language for scientific and engineering computing. It focuses on providing a comprehensive set of high-level numerical functions so that developers can quickly build up any data analytical applications. After over one-year intensive development and continuous optimisation, Owl has evolved into a powerful software system with competitive performance to mainstream numerical libraries. Meanwhile, Owl’s overall architecture remains simple and elegant, its small code base can be easily managed by a small group of developers.</p>
<p>In this chapter, we first present Owl’s design, core components, and its key functionality. We show that Owl benefits greatly from OCaml’s module system which not only allows us to write concise generic code with superior performance, but also leads to a very unique design to enable parallel and distributed computing. Oaml’s static type checking significantly reduces potential bugs and accelerates the development cycle. We also share the knowledge and lessons learnt from building up a full-fledge system for scientific computing with the functional programming community.</p>
<section class="level2" id="introduction">
<h2>Introduction</h2>
<p>Thanks to the recent advances in machine learning and deep neural networks, there is a huge demand on various numerical tools and libraries in order to facilitate both academic researchers and industrial developers to fast prototype and test their new ideas, then develop and deploy analytical applications at large scale. Take deep neural network as an example, Google invests heavily in TensorFlow while Facebook promotes their PyTorch. Beyond these libraries focusing on one specific numerical task, the interest on general purpose tools like Python and Julia also grows fast. Python has been one popular choice among developers for fast prototyping analytical applications, one important reason is because Scipy and Numpy two libraries, tightly integrated with other advanced functionality such as plotting, offer a powerful environment which lets developers write very concise code to finish complicated numerical tasks. As a result, even for the frameworks which were not originally developed in Python (such as Caffe and TensorFlow), they often provide Python bindings to take advantage of the existing numerical infrastructure in Numpy and Scipy.</p>
<p>On the other hand, the supporting of basic scientific computing in OCaml is rather fragmented. There have been some initial efforts (e.g., Lacaml, Oml, Pareto, and etc.), but their APIs are either too low-level to offer satisfying productivity, or the designs overly focus on a specific problem domain. Moreover, inconsistent data representation and careless use of abstract types make it difficult to pass data across different libraries. Consequently, developers often have to write a significant amount of boilerplate code just to finish rather trivial numerical tasks. As we can see, there is a severe lack of a general purpose numerical library in OCaml ecosystem. We believe OCaml per se is a good candidate for developing such a general purpose numerical library for two important reasons: 1) we can write functional code as concise as that in Python with typesafety; 2) OCaml code often has much superior performance comparing to dynamic languages such as Python and Julia.</p>
<p>However, designing and developing a full-fledged numerical library is a non-trivial task, despite that OCaml has been widely used in system programming such as MirageOS. The key difference between the two is obvious and interesting: system libraries provide a lean set of APIs to abstract complex and heterogeneous physical hardware, whilst numerical library offer a fat set of functions over a small set of abstract number types.</p>
<p>When Owl project started in 2016, we were immediately confronted by a series of fundamental questions like: “what should be the basic data types”, “what should be the core data structures”, “what modules should be designed”, and etc. In the following development and performance optimisation, we also tackled many research and engineering challenges on a wide range of different topics such as software engineering, language design, system and network programming, and etc.</p>
<p>In this chapter, We show that Owl benefits greatly from OCaml’s module system which not only allows us to write concise generic code with superior performance, but also leads to a very unique design to enable parallel and distributed computing. OCaml’s static type checking significantly reduces potential bugs and accelerate the development cycle. We would like to share the knowledge and lessons learnt from building up a full-fledge system for scientific computing with the functional programming community.</p>
</section>
<section class="level2" id="subsystems">
<h2>Subsystems</h2>
<section class="level3" id="architecture-overview-1">
<h3>Architecture Overview</h3>
<p>Owl is a complex library consisting of numerous functions (over 6500 by the end of 2017), we have strived for a modular design to make sure that the system is flexible enough to be extended in future. In the following, we will present its architecture briefly.</p>
<figure>
<img alt="" style="width:95.0%" id="fig:architecture:architecture" title="owl-architecture" src="images/architecture/owl-architecture.png"><figcaption>Figure 1: Owl system architecture</figcaption>
</figure>
<p>[@#fig:architecture:architecture] gives a bird view of Owl’s system architecture, i.e.&nbsp;the two subsystems and their modules. The subsystem on the left part is Owl’s Numerical Subsystem. The modules contained in this subsystem fall into three categories: (1) core modules contains basic data structures and foreign function interfaces to other libraries (e.g., CBLAS and LAPACKE); (2) classic analytics contains basic mathematical and statistical functions, linear algebra, regression, optimisation, plotting, and etc.; (3) composable service includes more advanced numerical techniques such as deep neural network, natural language processing, data processing and service deployment tools.</p>
<p>The numerical subsystem is further organised in a stack of smaller libraries, as follows.</p>
<ul>
<li><p><strong>Base</strong> is the basis of all other libraries in Owl. Base defines core data structures, exceptions, and part of numerical functions. Because it contains pure OCaml code so the applications built atop of Base can be safely compiled into native code, bytecode, JavaScript, even into unikernels. Fortunately, majority of Owl’s advanced functions are implemented in pure OCaml.</p></li>
<li><p><strong>Owl</strong> is the backbone of the numerical subsystem. It depends on Base but replaces some pure OCaml functions with C implementations (e.g.&nbsp;vectorised math functions in Ndarray module). Mixing C code into the library limits the choice of backends (e.g.&nbsp;browsers and MirageOS) but gives us significant performance improvement when running applications on CPU.</p></li>
<li><p><strong>Zoo</strong> is designed for packaging and sharing code snippets among users. This module targets small scripts and light numerical functions which may not be suitable for publishing on the heavier OPAM system. The code is distributed via gists on Github, and Zoo is able to resolve the dependency and automatically pull in and cache the code.</p></li>
<li><p><strong>Top</strong> is the Toplevel system of Owl. It automatically loads both Owl and Zoo, and installs multiple pretty printers for various data types.</p></li>
</ul>
<p>The subsystem on the right is called Actor Subsystem which extends Owl’s capability to parallel and distributed computing. The addition of Actor subsystem makes Owl fundamentally different from mainstream numerical libraries such as SciPy and Julia. The core idea is to transform a user application from sequential execution mode into parallel mode (using various computation engines) with minimal efforts. The method we used is to compose two subsystems together with functors to generate the parallel version of the module defined in the numerical subsystem.</p>
</section>
<section class="level3" id="core-data-structure">
<h3>Core Data Structure</h3>
<p>N-dimensional array and matrix are the building blocks of Owl library, their functionality are implemented in Ndarray and Matrix modules respectively. Matrix is a special case of n-dimensional array, and in fact many functions in Matrix module call the corresponding functions in Ndarray directly.</p>
<p>For n-dimensional array and matrix, Owl supports both dense and sparse data structures. The dense data structure is built atop of OCaml’s native Bigarray module hence it can be easily interfaced with other libraries like BLAS and LAPACK. Owl also supports both single and double precisions for both real and complex number. Therefore, Owl essentially has covered all the necessary number types in most common scientific computations.</p>
<ul>
<li><p>The first group contains the vectorised mathematical functions such as sin, cos, relu, and etc.</p></li>
<li><p>The second group contains the high-level functionality to manipulate arrays and matrices, e.g., index, slice, tile, repeat, pad, and etc.</p></li>
<li><p>The third group contains the linear algebra functions specifically for matrices. Almost all the linear algebra functions in Owl call directly the corresponding functions in CBLAS and LAPACKE.</p></li>
</ul>
<p>These functions together provide a strong support for developing high-level numerical functions. Especially the first two groups turn out to be extremely useful for writing machine learning and deep neural network applications. Function polymorphism is achieved using GADT (Generalized algebraic data type), therefore most functions in Generic module accept the input of four basic number types.</p>
</section>
<section class="level3" id="computation-graph">
<h3>Computation Graph</h3>
<p>Computation graph plays a critical role in our system, e.g.&nbsp;algorithmic differentiation, lazy evaluation, and GPU computing modules all implicitly or explicitly use computation graph to perform calculations. We will present the design of these modules over this topic.</p>
</section>
<section class="level3" id="algorithmic-differentiation">
<h3>Algorithmic Differentiation</h3>
<p>Atop of the core components, we have developed several modules to extend Owl’s numerical capability. E.g., Maths module includes many basic and advanced mathematical functions, whist <code>Stats</code> module provides various statistical functions such as random number generators, hypothesis tests, and so on. The most important extended module is Algodiff, which implements the algorithmic differentiation functionality. Owl’s Algodiff module is based on the core nested ´ automatic differentiation algorithm and differentiation API of DiffSharp, which provides support for both forward and reverse differentiation and arbitrary higher order derivatives.</p>
</section>
<section class="level3" id="optimisation">
<h3>Optimisation</h3>
<p>Algodiff module is able to provide the derivative, Jacobian, and Hessian of a large range of functions, we exploits this power to further build the optimisation engine. The optimisation engine is light and highly configurable, and also serves as the foundation of Regression module and Neural Network module because both are essentially mathematical optimisation problems. The flexibility in optimisation engine leads to an extremely compact design and small code base. For a fullfledge deep neural network module, we only use about 2500 LOC and its inference performance on CPU is superior to specialised frameworks such as TenserFlow and Caffee.</p>
</section>
<section class="level3" id="parallel-computing">
<h3>Parallel Computing</h3>
<p>Parallelism can take place at various levels, e.g.&nbsp;on multiple cores of the same CPU, or on multiple CPUs in a network, or even on a cluster of GPUs. OCaml official release only supports single threading model at the moment, and the work on Multicore OCaml is still ongoing in the Computer Lab in Cambridge. In the following, we will present how parallelism is achieved in Owl to speed up numerical computations.</p>
<p>The design of distributed and parallel computing module essentially differentiates Owl from other mainstream numerical libraries. For most libraries, the capability of distributed and parallel computing is often implemented as a third-party library, and the users have to deal with low-level message passing interfaces. However, Owl achieves such capability through its Actor subsystem.</p>
</section>
<section class="level3" id="gpu-computing">
<h3>GPU Computing</h3>
<p>Scientific computing involves intensive computations, and GPU has become an important option to accelerate these computations by performing parallel computation on its massive cores. There are two popular options in GPGPU computing: CUDA and OpenCL. CUDA is developed by Nvdia and specifically targets their own hardware platform whereas OpenCL is a cross platform solution and supported by multiple vendors. Owl currently supports OpenCL and CUDA support is included in our future plan.</p>
</section>
<section class="level3" id="openmp">
<h3>OpenMP</h3>
<p>OpenMP uses shared memory multi-threading model to provide parallel computation. It is requires both compiler support and linking to specific system libraries. OpenMP support is transparent to programmers, it can be enabled by turning on the corresponding compilation switch in jbuild file. After enabling OpenMP, many vectorised math operators are replaced with the corresponding OpenMP implementation in the compiling phase. Parallelism offered by OpenMP is not a free lunch, the scheduling mechanism adds extra overhead to a computation task. If the task per se is not computation heavy or the ndarray is small, OpenMP often slows down the computation. We therefore set a threshold on ndarray size below which OpenMP code is not triggered. This simple mechanism turns out to be very effective in practice.</p>
</section>
<section class="level3" id="interfaced-libraries">
<h3>Interfaced Libraries</h3>
<p>Some functionality such as plotting and linear algebra is included into the system by interfacing to other libraries. Rather than simply exposing the low-level functions, we carefully design easy-to-use high-level APIs and this section will cover these modules.</p>
<p><strong>Linear Algebra</strong> Even though Fortran is no longer among the top choices as a programming language, there is still a large body of Fortran numerical libraries whose performance still remain competitive even by today’s standard, e.g.&nbsp;BLAS and LAPACK. When designing the linear algebra module, we decide to interface to CBLAS and LAPACKE (i.e.&nbsp;the corresponding C interface of BLAS and LAPACK) then further build higher-level APIs atop of the low-level Fortran functions. The high-level APIs hides many tedious tasks such as setting memory layout, allocating workspace, calculating strides, and etc.</p>
<p><strong>Plotting</strong> Plotting is an indispensable function in modern numerical libraries. We build Plot module on top of PLplot which is a powerful cross-platform plotting library. However PLPlot only provides very low-level functions to interact with its multiple plotting engines, eveb making a simple plot involves very lengthy and tedious control sequence. Using these low-level functions directly requires developers to understand the mechanisms in depth, which not only significantly reduces the productivity but also is prone to errors. Inspired by Matlab, we implement Plot module to provide developers a set of high-level APIs. The core plotting engine is very lightweight and only contains about 200 LOC. Its core design is to cache all the plotting operations as a sequence of function closures and execute them all when we output the figure.</p>
</section>
</section>
<section class="level2" id="software-optimisation">
<h2>Software Optimisation</h2>
</section>
<section class="level2" id="community-driven-rd">
<h2>Community-Driven R&amp;D</h2>
<p>Owl is a large open source project, to guarantee quality of the software and sustainable development, we enforce the following rules in day-to-day research, development, and project management.</p>
<p>Besides coding, there are many other ways you can contribute. Bug reporting, typo fix, asking/answering questions, and improvement of existing documents are all well welcome.</p>
<p><strong>Coding Style</strong></p>
<p>Coding style guarantees a consistent taste of code written by different people. It improves code readability and maintainability in large software projects. OCaml is the main developing language in Owl. We use <a href="https://github.com/ocaml-ppx/ocamlformat">ocamlformat</a> to enforce the style of OCaml code. There is also a significant amount of C code in the project. For the C code, we apply the <a href="https://www.kernel.org/doc/html/v4.10/process/coding-style.html">Linux kernel coding style</a>. The coding style does not apply to the vendor’s code directly imported into Owl source code tree.</p>
<p><strong>Unit Test</strong></p>
<p>All the code must be well tested before submitting a pull request. If existing functions are modified, you need to run the unit tests to make sure the changes do not break any tests. If existing functions are modified, you may also need to add more unit tests for various edge cases which are not covered before. If new functions are added, you must add corresponding unit tests and make sure edge cases are well covered.</p>
<p><strong>Pull Request</strong></p>
<p>Minor improvement changes can be submitted directly in a pull request. The title and description of the pull request shall clearly describe the purpose of the PR, potential issues and caveats. For significant changes, please first submit a proposal on Owl’s issue tracker to initialise the discussion with Owl Team. For sub libraries building atop of Owl, if you want the library to be included in the owlbarn organisation, please also submit the proposal on issue tracker. Note that the license of the library must be compliant with owlbarn, i.e.&nbsp;MIT or BSD compliant. Exception is possible but must be discussed with Owl Team first. Pull requests must be reviewed and approved by at least two key developers in Owl Team. A designated person in Owl Team will be responsible for assigning reviewers, tagging a pull request, and final merging to the master branch.</p>
<p><strong>Documentation</strong></p>
<p>For inline documentation in the code, the following rules apply. - Be concise, simple, and correct. - Make sure the grammar is correct. - Refer to the original paper whenever possible. - Use both long documentation in mli and short inline documentation in code.</p>
<p>For serious technical writing, please contribute to Owl’s Tutorial Book. - Fixing typos, grammar issues, broken links, and improving tutorial tooling are considered as minor changes. You can submit pull requests directly to Tutorial Book repository. - Extending existing chapters are medium changes and you need to submit a proposal to Tutorial Book issue tracker. - Contributing a standalone chapter also requires submitting a chapter proposal. Alternatively, you can write to me directly to discuss about the chapter.</p>
<p>Becoming A Team Member (?)</p>
</section>
<section class="level2 unnumbered" id="references">
<h2 class="unnumbered">References</h2>
<div role="doc-bibliography" class="references hanging-indent" id="refs">
<div id="ref-minsky2013real">
<p>Minsky, Yaron, Anil Madhavapeddy, and Jason Hickey. 2013. <em>Real World Ocaml: Functional Programming for the Masses</em>. " O’Reilly Media, Inc.".</p>
</div>
<div id="ref-wang2017owl">
<p>Wang, Liang. 2017. “Owl: A General-Purpose Numerical Library in Ocaml. CoRR Abs/1707.09616 (2017).”</p>
</div>
</div>
</section>
</section>
</article></div><a href="core-opt.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 20</small>Core Optimisation</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz">ocaml.xyz</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>Copyright 2017-2020 Liang Wang.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>