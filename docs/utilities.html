<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Internal Utility Modules - OCaml Scientific Computing</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing</h1><h5>1<sup>st</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.xyz/package/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="internal-utility-modules">
<h1>Internal Utility Modules</h1>
<p>During development of Owl, we find some utility modules are immensely handy. In this chapter, we share some of them. These are not the main feature of Owl, and perhaps you can implement your own version very quickly. But we hope to present how these features are used in Owl.</p>
<section class="level2" id="dataset-module">
<h2>Dataset Module</h2>
<p>The dataset modules provides easy access to various datasets to be used in Owl, mainly the MNSIT and CIFAR10 datasets. You can get all these data in Owl by executing: <code>Dataset.download_all ()</code>. The data are downloaded in the home directory, for example, <code>~/.owl/dataset</code> on Linux.</p>
<section class="level3" id="mnist">
<h3>MNIST</h3>
<p>The <a href="http://yann.lecun.com/exdb/mnist/">MNIST database</a> of handwritten digits has a training set of 60,000 examples, and a test set of 10,000 examples. Each example is of size 28 x 28. It is a good starting point for deep neural network related tasks.</p>
<p>You can get MNIST data via these Owl functions:</p>
<ul>
<li><p><code>Dataset.load_mnist_train_data ()</code>: returns a triplet <code>x, y, y'</code>.</p>
<ul>
<li><code>x</code> is a [60000, 784] ndarray (<code>Owl_dense_ndarray.S.mat</code>) where each row represents a [28, 28] image.</li>
<li><code>y</code> is a [60000, 1] label ndarray. Each row is an integer ranging from 0 to 9, indicating the digit on each image.</li>
<li><code>y'</code> is a [60000, 10] label ndarray. Each one-hot row vector corresponds to one label.</li>
</ul></li>
<li><p><code>Dataset.load_mnist_test_data ()</code>: returns a triplet. Similar to <code>load_mnist_train_data</code>, only that it returns the test set, so the example size is 10,000 instead of 60,000.</p></li>
<li><p><code>Dataset.load_mnist_train_data_arr ()</code>: similar to <code>load_mnist_train_data</code>, but returns <code>x</code> as [60000,28,28,1] ndarray</p></li>
<li><p><code>Dataset.load_mnist_test_data_arr ()</code>: similar to <code>load_mnist_train_data_arr</code>, but it returns the test set, so the example size is 10, 000 instead of 60, 000.</p></li>
<li><p><code>Dataset.draw_samples x y n</code> draws <code>n</code> random examples from images ndarray <code>x</code> and label ndarray <code>y</code>.</p></li>
</ul>
<p>You can find the MNIST dataset used in training and testing a DNN in Owl:</p>
<div class="highlight">
<pre><code class="language-clike">let train network =
  let x, _, y = Dataset.load_mnist_train_data_arr () in
  Graph.train network x y |&gt; ignore;
  network

let test network =
  let imgs, _, labels = Dataset.load_mnist_test_data () in
  let m = Dense.Matrix.S.row_num imgs in
  let imgs = Dense.Ndarray.S.reshape imgs [|m;28;28;1|] in

  let mat2num x = Dense.Matrix.S.of_array (
      x |&gt; Dense.Matrix.Generic.max_rows
        |&gt; Array.map (fun (_,_,num) -&gt; float_of_int num)
    ) 1 m
  in

  let pred = mat2num (Graph.model network imgs) in
  let fact = mat2num labels in
  let accu = Dense.Matrix.S.(elt_equal pred fact |&gt; sum') in
  Owl_log.info "Accuracy on test set: %f" (accu /. (float_of_int m))</code></pre>
</div>
</section>
<section class="level3" id="cifar-10">
<h3>CIFAR-10</h3>
<p>The <a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10 dataset</a> include small scale color images for more realistic complex image classification tasks. It includes 10 classes of images: aeroplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck. It consists of 60,000 32 x 32 colour images in 10 classes, with 6,000 images per class. There are 50,000 training images and 10,000 test images.</p>
<p>Due to the limit of file size on Github, the training set is cut into 5 smaller batch. You can get CIFAR-10 data using <code>Owl</code>:</p>
<ul>
<li><p><code>Dataset.load_cifar_train_data batch</code>: returns a triplet <code>x, y, y'</code>.</p>
<ul>
<li>The input paramter <code>batch</code> can range from 1 to 5, indicating which training set batch to choose.</li>
<li><code>x</code> is an [10000, 32, 32, 3] ndarray (<code>Owl_dense_ndarray.S.arr</code>). The last dimension indicates color channels (first Red, then Green, finally Blue).</li>
<li><code>y</code> is an [10000, 1] label ndarray, each number representing an image class.</li>
<li><code>y'</code> is the corresponding [10000, 10] one-hot label ndarray.</li>
</ul></li>
<li><p><code>Dataset.load_cifar_test_data ()</code>: similar to <code>load_cifar_train_data</code>, only that it loads test data.</p></li>
<li><p><code>Dataset.draw_samples_cifar x y n</code> draws <code>n</code> random examples from images ndarray <code>x</code> and label ndarray <code>y</code>.</p></li>
</ul>
<p>Note that all elements in the loaded matrices and ndarrays are of <code>float32</code> format.</p>
<p>The CIFAR10 dataset is similar to MNIST in training DNN:</p>
<div class="highlight">
<pre><code class="language-clike">let train network =
  let x, _, y = Dataset.load_cifar_train_data 1 in
  Graph.train network x y</code></pre>
</div>
</section>
<section class="level3" id="text-datasets">
<h3>Text Datasets</h3>
</section>
</section>
<section class="level2" id="graph-module">
<h2>Graph Module</h2>
<p>The Graph module in Owl provides a general data structure to manipulate graphs. It is defined as:</p>
<div class="highlight">
<pre><code class="language-ocaml">type 'a node =
  { mutable id : int
  ; (* unique identifier *)
    mutable name : string
  ; (* name of the node *)
    mutable prev : 'a node array
  ; (* parents of the node *)
    mutable next : 'a node array
  ; (* children of the node *)
    mutable attr : 'a (* indicate the validity *)
  }</code></pre>
</div>
<p>The attribution here is generic so that you can define your own graph where each node contains an integer, a string, or any data type you define. This make the graph module extremely flexible.</p>
<p>Graph module provides a rich set of APIs. First, you can build a Graph using these methods:</p>
<ul>
<li><p><code>node ~id ~name ~prev ~next attr</code> creates a node with given id and name string. The created node is also connected to parents in <code>prev</code> and children in <code>next</code>. The <code>attr</code> will be saved in <code>attr</code> field.</p></li>
<li><p><code>connect parents children</code> connects a set of parents to a set of children. The created links are the Cartesian product of parents and children. In other words, they are bidirectional links between parents and children. Note that this function does not eliminate any duplicates in the array.</p></li>
<li><p><code>connect_descendants parents children</code> connects parents to their children. This function creates unidirectional links from parents to children. In other words, this function save <code>children</code> to <code>parent.next</code> field.</p></li>
<li><p><code>connect_ancestors parents children</code> connects children to their parents. This function creates unidirectional links from children to parents. In other words, this function save <code>parents</code> to <code>child.prev</code> field.</p></li>
<li><p><code>remove_node x</code> removes node <code>x</code> from the graph by disconnecting itself from all its parent nodes and child nodes.</p></li>
<li><p><code>remove_edge src dst</code> removes a link <code>src -&gt; dst</code> from the graph. Namely, the corresponding entry of <code>dst</code> in <code>src.next</code> and <code>src</code> in <code>dst.prev</code> will be removed. Note that it does not remove [dst -&gt; src] if there exists one.</p></li>
<li><p><code>replace_child x y</code> replaces <code>x</code> with <code>y</code> in <code>x</code> parents. Namely, <code>x</code> parents now make link to <code>y</code> rather than <code>x</code> in <code>next</code> field. Note that the function does note make link from <code>y</code> to <code>x</code> children. Namely, the <code>next</code> field of <code>y</code> remains intact.</p></li>
</ul>
<p>Then, to obtain and update properties of a graph:</p>
<div class="highlight">
<pre><code class="language-clike">val id : 'a node -&gt; int
(** ``id x`` returns the id of node ``x``. *)

val name : 'a node -&gt; string
(** ``name x`` returns the name string of node ``x``. *)

val set_name : 'a node -&gt; string -&gt; unit
(** ``set_name x s`` sets the name string of node ``x`` to ``s``. *)

val parents : 'a node -&gt; 'a node array
(** ``parents x`` returns the parents of node ``x``. *)

val set_parents : 'a node -&gt; 'a node array -&gt; unit
(** ``set_parents x parents`` set ``x`` parents to ``parents``. *)

val children : 'a node -&gt; 'a node array
(** ``children x`` returns the children of node ``x``. *)

val set_children : 'a node -&gt; 'a node array -&gt; unit
(** ``set_children x children`` sets ``x`` children to ``children``. *)

val attr : 'a node -&gt; 'a
(** ``attr x`` returns the ``attr`` field of node ``x``. *)

val set_attr : 'a node -&gt; 'a -&gt; unit
(** ``set_attr x`` sets the ``attr`` field of node ``x``. *)</code></pre>
</div>
<p>Similarly, you can get other properties of a graph use the other functions:</p>
<div class="highlight">
<pre><code class="language-clike">
val indegree : 'a node -&gt; int
(** ``indegree x`` returns the in-degree of node ``x``. *)

val outdegree : 'a node -&gt; int
(** ``outdegree x`` returns the out-degree of node ``x``. *)

val degree : 'a node -&gt; int
(** ``degree x`` returns the total number of links of ``x``. *)

val num_ancestor : 'a node array -&gt; int
(** ``num_ancestor x`` returns the number of ancestors of ``x``. *)

val num_descendant : 'a node array -&gt; int
(** ``num_descendant x`` returns the number of descendants of ``x``. *)

val length : 'a node array -&gt; int
(** ``length x`` returns the total number of ancestors and descendants of ``x``. *)</code></pre>
</div>
<p>Finally, we provide functions for traversing the graph in either Breadth-First order or Depth-First order. You can also choose to iterate the descendants or ancestors of a given node.</p>
<div class="highlight">
<pre><code class="language-clike">val iter_ancestors
  :  ?order:order
  -&gt; ?traversal:traversal
  -&gt; ('a node -&gt; unit)
  -&gt; 'a node array
  -&gt; unit
(** Iterate the ancestors of a given node. *)

val iter_descendants
  :  ?order:order
  -&gt; ?traversal:traversal
  -&gt; ('a node -&gt; unit)
  -&gt; 'a node array
  -&gt; unit
(** Iterate the descendants of a given node. *)

val iter_in_edges : ?order:order -&gt; ('a node -&gt; 'a node -&gt; unit) -&gt; 'a node array -&gt; unit
(** Iterate all the in-edges of a given node. *)

val iter_out_edges : ?order:order -&gt; ('a node -&gt; 'a node -&gt; unit) -&gt; 'a node array -&gt; unit
(** Iterate all the out-edges of a given node. *)

val topo_sort : 'a node array -&gt; 'a node array
(** Topological sort of a given graph using a DFS order. Assumes that the graph is acyclic.*)</code></pre>
</div>
<p>You can also use functions: <code>filter_ancestors</code>, <code>filter_descendants</code>, <code>fold_ancestors</code>, <code>fold_descendants</code>, <code>fold_in_edges</code>, and <code>fold_out_edges</code> to perform fold or filter operations when iterating the graph.</p>
<p>Within Owl, the Graph module is heavily use to facilitate the Computation Graph module.</p>
<p>TODO: Explain how it is used in CGraph.</p>
</section>
<section class="level2" id="stack-module">
<h2>Stack Module</h2>
</section>
<section class="level2" id="heap-module">
<h2>Heap Module</h2>
</section>
<section class="level2" id="count-min-sketch">
<h2>Count-Min Sketch</h2>
</section>
</section>
</article></div><a href="case-image-inception.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 29</small>Case - Image Recognition</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz">ocaml.xyz</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>Copyright 2017-2020 Liang Wang.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>