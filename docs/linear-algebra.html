<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Linear Algebra - OCaml Scientific Computing</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="https://use.typekit.net/gfj8wez.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>OCaml Scientific Computing</h1><h5>1<sup>st</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.xyz/package/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="linear-algebra">
<h1>Linear Algebra</h1>
<p>Linear Algebra: important. It is beyond the scope of this book. Please refer to <span data-cites="strang2006linear" class="citation">(Strang 2006)</span> for this subject. This chapter also follows the basic structure of this book.</p>
<p>This chapter briefly covers the linear algebra modules in Owl.</p>
<p>There are two levels abstraction in Owl’s <code>Linalg</code> module: * low-level raw interface to CBLAS and LAPACKE; * high-level wrapper functions in <code>Linalg</code> module; The example in this chapter mostly use the high level wrapper. Please refer to the last section for details on CBLAS.</p>
<p>The <code>Linalg</code> has the following module structure:</p>
<ul>
<li><p><a href="https://github.com/owlbarn/owl/blob/master/src/owl/linalg/owl_linalg_generic.mli">Owl.Linalg.Generic</a>: generic functions for four number types <code>S/D/C/Z</code>.</p></li>
<li><p><a href="https://github.com/owlbarn/owl/blob/master/src/owl/linalg/owl_linalg_s.mli">Owl.Linalg.S</a>: only for <code>float32</code> type.</p></li>
<li><p><a href="https://github.com/owlbarn/owl/blob/master/src/owl/linalg/owl_linalg_d.mli">Owl.Linalg.D</a>: only for <code>float64</code> type.</p></li>
<li><p><a href="https://github.com/owlbarn/owl/blob/master/src/owl/linalg/owl_linalg_c.mli">Owl.Linalg.C</a>: only for <code>complex32</code> type.</p></li>
<li><p><a href="https://github.com/owlbarn/owl/blob/master/src/owl/linalg/owl_linalg_z.mli">Owl.Linalg.Z</a>: only for <code>complex64</code> type.</p></li>
</ul>
<p><code>Generic</code> actually can do everything that <code>S/D/C/Z</code> can but needs some extra type information. The functions in <code>Linalg</code> module are divided into the following groups.</p>
<section class="level2" id="vectors-and-matrices">
<h2>Vectors and Matrices</h2>
<p>The fundamental problem of linear algebra: solving linear equations. This is more efficiently expressed with vectors and matrices. We need to get familiar with these basic structures in Owl.</p>
<p>Owl supports eight kinds of matrices as below, all the elements in a matrix are (real/complex) numbers.</p>
<ul>
<li><code>Dense.Matrix.S</code> : Dense matrices of single precision float numbers.</li>
<li><code>Dense.Matrix.D</code> : Dense matrices of double precision float numbers.</li>
<li><code>Dense.Matrix.C</code> : Dense matrices of single precision complex numbers.</li>
<li><code>Dense.Matrix.Z</code> : Dense matrices of double precision complex numbers.</li>
</ul>
<p>There are many common functions shared by these eight modules, therefore I will use <code>Mat</code> module (which is an alias of <code>Dense.Matrix.D</code> module) in the following examples. These examples should be able to applied to other modules without too much changes, but note some modules do have its own specific functions such as <code>Dense.Matrix.Z.re</code>.</p>
<section class="level3" id="create-matrices">
<h3>Create Matrices</h3>
<p>There are multiple functions to help you in creating an initial matrix to start with.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.empty 5 5;;        (* create a 5 x 5 matrix with initialising elements *)
  Mat.create 5 5 2.;;    (* create a 5 x 5 matrix and initialise all to 2. *)
  Mat.zeros 5 5;;        (* create a 5 x 5 matrix of all zeros *)
  Mat.ones 5 5;;         (* create a 5 x 5 matrix of all ones *)
  Mat.eye 5;;            (* create a 5 x 5 identity matrix *)
  Mat.uniform 5 5;       (* create a 5 x 5 random matrix of uniform distribution *)
  Mat.uniform_int 5 5;;  (* create a 5 x 5 random integer matrix *)
  Mat.sequential 5 5;;   (* create a 5 x 5 matrix of sequential integers *)
  Mat.semidef 5;;        (* create a 5 x 5 random semi-definite matrix *)
  Mat.gaussian 5 5;;     (* create a 5 x 5 random Gaussian matrix *)
</code></pre>
</div>
<p>As you noticed, the last example is to create a random matrix where the elements follow a Gaussian distribution. What about creating another matrix where the element follow another distribution, e.g., <code>t-distribution</code>? Easy!</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.(empty 5 5 |&gt; map (fun _ -&gt; Stats.t_rvs ~df:1. ~loc:0. ~scale:1.));;
&gt;- : Mat.mat =
&gt;
&gt;          C0        C1        C2          C3        C4
&gt;R0   1.44768 -0.349538 -0.600692    -15.6261   2.07554
&gt;R1  -1.25034   1.20008  -1.76243   -0.719415 -0.580605
&gt;R2  -1.71484   10.1152 -0.138612    0.276529 -0.355326
&gt;R3   0.83227  -6.36336   1.48695 -0.00277443 -0.791397
&gt;R4 -0.336031   -1.7789 -0.113224     4.15084   -2.1577
</code></pre>
</div>
<p>So, what we did is first creating an empty <code>5 x 5</code> matrix, then mapping each element to a random number following <code>t-distribution</code>. The example utilises Owl’s <code>Stats</code> module which I will introduce in another tutorial.</p>
<p>Alternatively, you can use <code>uniform</code> function to generate the input values, as below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.(uniform 5 5 |&gt; map Maths.sin);;
&gt;- : Mat.mat =
&gt;
&gt;         C0        C1       C2       C3       C4
&gt;R0  0.11068 0.0997998 0.185571 0.521833 0.583662
&gt;R1 0.818164  0.426204 0.524001 0.395543 0.590104
&gt;R2 0.420941  0.496159 0.084013 0.425077 0.443924
&gt;R3 0.694034  0.147498 0.430752 0.302604 0.128698
&gt;R4 0.840643  0.163237 0.658268 0.457176 0.175289
</code></pre>
</div>
<p>Owl can create some special matrices with specific properties. For example, a <em>magic square</em> is a <code>n x n</code> matrix (where n is the number of cells on each side) filled with distinct positive integers in the range <span class="math inline">\(1,2,...,n^{2}\)</span> such that each cell contains a different integer and the sum of the integers in each row, column and diagonal is equal.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Mat.magic 5;;
&gt;val x : Mat.mat =
&gt;
&gt;   C0 C1 C2 C3 C4
&gt;R0 17 24  1  8 15
&gt;R1 23  5  7 14 16
&gt;R2  4  6 13 20 22
&gt;R3 10 12 19 21  3
&gt;R4 11 18 25  2  9
</code></pre>
</div>
<p>We can validate this property with the following code. The summation of all the elements on each column is 65.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.sum_rows x;;
&gt;- : Mat.mat =
&gt;   C0 C1 C2 C3 C4
&gt;R0 65 65 65 65 65
</code></pre>
</div>
<p>The summation of all the elements on each row is 65.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.sum_cols x;;
&gt;- : Mat.mat =
&gt;   C0
&gt;R0 65
&gt;R1 65
&gt;R2 65
&gt;R3 65
&gt;R4 65
</code></pre>
</div>
<p>The summation of all the diagonal elements is also 65.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.trace x;;
&gt;- : float = 65.
</code></pre>
</div>
<p>The last example creates three matrices where the elements follow Bernoulli distribution of different parameters. We then use <code>Plot.spy</code> function to visualise how the non-zero elements are distributed in the matrices.</p>
<div class="highlight">
<pre><code class="language-ocaml">let x = Mat.bernoulli ~p:0.1 40 40 in
let y = Mat.bernoulli ~p:0.2 40 40 in
let z = Mat.bernoulli ~p:0.3 40 40 in

let h = Plot.create ~m:1 ~n:3 "plot_00.png" in
Plot.subplot h 0 0;
Plot.spy ~h x;
Plot.subplot h 0 1;
Plot.spy ~h y;
Plot.subplot h 0 2;
Plot.spy ~h z;
Plot.output h;;</code></pre>
</div>
<figure>
<img alt="" style="width:90.0%" id="fig:linear-algebra:mat_plot_00" title="plot 00" src="images/matrix/plot_00.png"><figcaption>Figure 1: Visualise the distribution of non-zero elements in matrices.</figcaption>
</figure>
</section>
<section class="level3" id="access-elements">
<h3>Access Elements</h3>
<p>All four matrix modules support <code>set</code> and <code>get</code> to access and modify matrix elements.</p>
<div class="highlight">
<pre><code class="language-ocaml">
let x = Mat.uniform 5 5;;
Mat.set x 1 2 0.;;             (* set the element at (1,2) to 0. *)
Mat.get x 0 3;;                (* get the value of the element at (0,3) *)
</code></pre>
</div>
<p>For dense matrices, i.e., <code>Dense.Matrix.*</code>, you can also use shorthand <code>.%{[|i,j|]}</code> to access elements.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">open Mat;;
x.%{[|1;2|]} &lt;- 0.;;         (* set the element at (1,2) to 0. *);;
&gt;- : unit = ()
let a = x.%{[|0;3|]};;       (* get the value of the element at (0,3) *);;
&gt;val a : float = 0.181287028128281236
</code></pre>
</div>
<p>The modifications to a matrix using <code>set</code> are in-place. This is always true for dense matrices. For sparse matrices, the thing can be complicated because of performance issues. I will discuss about sparse matrices separately in a separate post.</p>
</section>
<section class="level3" id="iterate-elements-rows-columns">
<h3>Iterate Elements, Rows, Columns</h3>
<p>In reality, a matrix usually represents a collections of measurements (or points). We often need to go through these data again and again for various reasons. Owl provides very convenient functions to help you to iterate these elements. There is one thing I want to emphasise: Owl uses row-major matrix for storage format in the memory, which means accessing rows are much faster than those column operations.</p>
<p>Let’s first create a <code>4 x 6</code> matrix of sequential numbers as below.</p>
<div class="highlight">
<pre><code class="language-ocaml">
let x = Mat.sequential 4 6;;
</code></pre>
</div>
<p>You should be able to see the following output in your <code>utop</code>.</p>
<div class="highlight">
<pre><code class="language-text">
     C0 C1 C2 C3 C4 C5
  R0  1  2  3  4  5  6
  R1  7  8  9 10 11 12
  R2 13 14 15 16 17 18
  R3 19 20 21 22 23 24
</code></pre>
</div>
<p>Iterating all the elements can be done by using <code>iteri</code> function. The following example prints out all the elements on the screen.</p>
<div class="highlight">
<pre><code class="language-ocaml">
Mat.iteri_2d (fun i j a -&gt; Printf.printf "(%i,%i) %.1f\n" i j a) x;;
</code></pre>
</div>
<p>If you want to create a new matrix out of the existing one, you need <code>mapi</code> and <code>map</code> function. E.g., we create a new matrix by adding one to each element in <code>x</code>.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.map ((+.) 1.) x;;
&gt;- : Mat.mat =
&gt;
&gt;   C0 C1 C2 C3 C4 C5
&gt;R0  1  2  3  4  5  6
&gt;R1  7  8  9 10 11 12
&gt;R2 13 14 15 16 17 18
&gt;R3 19 20 21 22 23 24
</code></pre>
</div>
<p>We can take some rows out of <code>x</code> by calling <code>rows</code> function. The selected rows will be used to assemble a new matrix.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.rows x [|0;2|];;
&gt;- : Mat.mat =
&gt;
&gt;   C0 C1 C2 C3 C4 C5
&gt;R0  0  1  2  3  4  5
&gt;R1 12 13 14 15 16 17
</code></pre>
</div>
<p>Similarly, we can also select some columns as below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.cols x [|3;2;1|];;
&gt;- : Mat.mat =
&gt;
&gt;   C0 C1 C2
&gt;R0  3  2  1
&gt;R1  9  8  7
&gt;R2 15 14 13
&gt;R3 21 20 19
</code></pre>
</div>
<p>Iterating rows and columns are similar to iterating elements, by using <code>iteri_rows</code>, <code>mapi_rows</code>, and etc. The following example prints the sum of each row.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.iteri_rows (fun i r -&gt;
    Printf.printf "row %i: %.1f\n" i (Mat.sum' r)
  ) x;;
</code></pre>
</div>
<p>You can also fold elements, rows, and columns. Let’s first calculate the summation of all elements.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.fold (+.) 0. x;;
</code></pre>
</div>
<p>Now, we calculate the summation of all column vectors by using <code>fold_cols</code> fucntion.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  let v = Mat.(zeros (row_num x) 1) in
  Mat.(fold_cols add v x);;
</code></pre>
</div>
<p>It is also possible to change a specific row or column. E.g., we make a new matrix out of <code>x</code> by setting row <code>2</code> to zero vector.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.map_at_row (fun _ -&gt; 0.) x 2;;
</code></pre>
</div>
</section>
<section class="level3" id="filter-elements-rows-columns">
<h3>Filter Elements, Rows, Columns</h3>
<p>To continue use the previous sequential matrix, I will make some examples to show how to examine and filter elements in a matrix. The first one is to filter out the elements in <code>x</code> greater than <code>20</code>.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.filter ((&lt;) 20.) x;;
&gt;- : int array = [|21; 22; 23|]
</code></pre>
</div>
<p>You can compare the next example which filters out the two-dimensional indices.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.filteri_2d (fun i j a -&gt; a &gt; 20.) x;;
&gt;- : (int * int) array = [|(3, 3); (3, 4); (3, 5)|]
</code></pre>
</div>
<p>The second example is to filter out the rows whose summation is less than <code>22</code>.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.filter_rows (fun r -&gt; Mat.sum' r &lt; 22.) x;;
&gt;- : int array = [|0|]
</code></pre>
</div>
<p>If we want to check whether there is one or (or all) element in <code>x</code> satisfying some condition, then</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.exists ((&gt;) 5.) x;;      (* is there someone smaller than 5. *)
  Mat.not_exists ((&gt;) 5.) x;;  (* is no one smaller than 5. *)
  Mat.for_all ((&gt;) 5.) x;;     (* is everyone smaller than 5. *)
</code></pre>
</div>
</section>
<section class="level3" id="compare-two-matrices">
<h3>Compare Two Matrices</h3>
<p>Comparing two matrices is just so easy by using module infix <code>=@</code>, <code>&lt;&gt;@</code>, <code>&gt;@</code>, and etc. Let’s first create another matrix <code>y</code> by multiplying two to every elements in <code>x</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  let y = Mat.map (( *. ) 2.) x;;
</code></pre>
</div>
<p>Then we can compare the relationship of <code>x</code> and <code>y</code> as below. Note, the relationship is derived by checking every elements in both matrices. E.g., <code>x</code> is equal to <code>y</code> means every element in <code>x</code> is equal the corresponding element in <code>y</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.(x = y);;    (* is x equal to y *)
  Mat.(x &lt;&gt; y);;   (* is x unequal to y *)
  Mat.(x &gt; y);;    (* is x greater to y *)
  Mat.(x &lt; y);;    (* is x smaller to y *)
  Mat.(x &gt;= y);;   (* is x not smaller to y *)
  Mat.(x &lt;= y);;   (* is x not greater to y *)
</code></pre>
</div>
<p>All aforementioned infix have their corresponding functions in the module, e.g., <code>=@</code> has <code>Mat.is_equal</code>. Please refer to the documentation.</p>
</section>
<section class="level3" id="matrix-arithmetics">
<h3>Matrix Arithmetics</h3>
<p>The arithmetic operation also heavily uses infix. Similar to matrix comparison, each infix has its corresponding function in the module.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.(x + y);;    (* add two matrices *)
  Mat.(x - y);;    (* subtract y from x *)
  Mat.(x * y);;    (* element-wise multiplication *)
  Mat.(x / y);;    (* element-wise division *)
  Mat.(x *@ y);;    (* dot product of x and y *)
</code></pre>
</div>
<p>If you do match between a matrix and a scalar value, you need to be careful about their order. Please see the examples below. In the following examples, <code>x</code> is a matrix as we used before, and <code>a</code> is a <code>float</code> scalar value.</p>
<div class="highlight">
<pre><code class="language-ocaml">  let a = 2.5;;

  Mat.(x +$ a);;    (* add a to every element in x *)
  Mat.(a $+ x);;    (* add a to every element in x *)
</code></pre>
</div>
<p>Similarly, we have the following examples for other math operations.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.(x -$ a);;    (* sub a from every element in x *)
  Mat.(a $- x);;
  Mat.(x *$ a);;    (* mul a with every element in x *)
  Mat.(a $* x);;
  Mat.(x /$ a);;    (* div a to every element in x *)
  Mat.(a $/ x);;
  Mat.(x **$ a);;   (* power of every element in x *)
</code></pre>
</div>
<p>There are some ready-made functions to ease your life when operating matrices.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.log10 x;;     (* logarithm of every element in x *)
  Mat.abs x;;       (* absolute value of every element in x *)
  Mat.neg x;;       (* negation of every element in x *)
</code></pre>
</div>
<p>For more advanced operations such as <code>svd</code> and <code>qr</code> operations, you need to use <code>Linalg</code> module. Currently, <code>Linalg</code> only works on dense matrices of real numbers. I will provide more supports for other types of matrices in future.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Linalg.D.svd x;;  (* svd of x *)
  Linalg.D.qr x;;   (* QR decomposition of x *)
  Linalg.D.inv x;;  (* inverse of x *)
  Linalg.D.det x;;  (* determinant of x *)
</code></pre>
</div>
</section>
<section class="level3" id="save-load-matrices">
<h3>Save &amp; Load Matrices</h3>
<p>All matrices can be serialised to storage by using <code>save</code>. Later, you can load a matrix using <code>load</code> function.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.save "m0.mat" x;;    (* save x to m0.mat file *)
  Mat.load "m0.mat";;      (* load m0.mat back to the memory *)
</code></pre>
</div>
<p>I also made corresponding <code>save_txt</code> and <code>load_txt</code> functions for a simple tab-delimited, human-readable format. Note the performance is much worse than the corresponding <code>save</code> and <code>load</code>.</p>
</section>
<section class="level3" id="other-operations">
<h3>Other Operations</h3>
<p>I will use another set of examples to finish this tutorial. I must say this tutorial has not presented all the operations provided by Owl’s matrix modules. There are much more operations you can explore by reading its documents.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  Mat.(x @= y);;    (* concatenate x and y vertically *)
  Mat.(x @|| y);;   (* concatenate x and y horizontally *)
</code></pre>
</div>
<div class="highlight">
<pre><code class="language-ocaml">  let x = Sparse.Matrix.D.uniform 10 10;; (* create a sparse matrix with uniform rvs *)
  Sparse.Matrix.D.map_nz ((+.) 1.) x;;    (* add one to non-zero elements in a sparse matrix *)
  Sparse.Matrix.D.density x;;             (* show the density of a sparse matrix *)
</code></pre>
</div>
</section>
</section>
<section class="level2" id="gaussian-elimination">
<h2>Gaussian Elimination</h2>
<p>Solving linear equations systems is the core problem in Linear Algebra and is frequently used in scientific computation. <em>Gaussian Elimination</em> is a classic method to do that. With a bit of techniques, elimination works surprisingly well in modern numerical libraries as one way of implementation. Here is a simple example.</p>
<p><span class="math display">\[2x_1 + 2x_2 + 2x_3 = 4\]</span> <span id="eq:linear-algebra:gauss01"><span class="math display">\[2x_1 + 2x_2 + 3x_3 = 5\qquad(1)\]</span></span> <span class="math display">\[3w_1 + 4x_2 + 5x_3 = 7\]</span></p>
<p>Divide the first equation by 2:</p>
<p><span class="math display">\[x_1 + x_2 + x_3 = 2\]</span> <span id="eq:linear-algebra:gauss02"><span class="math display">\[2x_1 + 2x_2 + 3x_3 = 5\qquad(2)\]</span></span> <span class="math display">\[3w_1 + 4x_2 + 5x_3 = 7\]</span></p>
<p>Multiply the first equation by <code>-2</code>, then add it to the second one. Also, multiply the first equation by <code>-3</code>, then add it to the third one. We have:</p>
<p><span class="math display">\[x_1 + x_2 + x_3 = 2\]</span> <span id="eq:linear-algebra:gauss03"><span class="math display">\[x_3 = 1\qquad(3)\]</span></span> <span class="math display">\[x_2 + 2x_3 = 1\]</span></p>
<p>Finally, swap the second and third line:</p>
<p><span class="math display">\[x_1 + x_2 + x_3 = 2\]</span> <span id="eq:linear-algebra:gauss04"><span class="math display">\[x_2 + 2x_3 = 1\qquad(4)\]</span></span> <span class="math display">\[x_3 = 1\]</span></p>
<p>Here <span class="math inline">\(x_3 = 1\)</span>, and we can put it back in the second equation and get <span class="math inline">\(x_2 = -1\)</span>. Put both back to the first equation and we have <span class="math inline">\(x_1 = 2\)</span></p>
<p>This process demonstrate the basic process of elimination: eliminate unknown variables until this group of linear equations is easy to solve, and then do the back-substitution. There are three kinds of basic operations we can use: multiplication, adding one line to another, and swap two lines.</p>
<p>The starting eq.&nbsp;1 can be more concisely expressed with vector:</p>
<p><span class="math display">\[x_1\left[\begin{matrix}2\\2\\3\end{matrix} \right] + x_2\left[\begin{matrix}2\\2\\4\end{matrix} \right] + x_3\left[\begin{matrix}2\\3\\5\end{matrix} \right] = \left[\begin{matrix}4\\5\\7\end{matrix} \right]\]</span></p>
<p>or it can be expressed as <span class="math inline">\(Ax=b\)</span> using matrix notation.</p>
<p><span class="math display">\[\left[\begin{matrix}2 &amp; 2 &amp; 2\\2 &amp; 2 &amp; 3\\3 &amp; 4 &amp; 5\end{matrix} \right] \left[\begin{matrix}x_1\\x_2\\x_3\end{matrix} \right] = \left[\begin{matrix}4\\5\\7\end{matrix} \right]\]</span></p>
<p>Here A is a matrix, b is a column vector, and x is the unknown vector. The matrix notation is often used to describe the linear equation systems as a concise way.</p>
<section class="level3" id="lu-factorisation">
<h3>LU Factorisation</h3>
<p>Let’s check the gaussian elimination example again. The final form in eq.&nbsp;4 can be expressed with the matrix notation as:</p>
<p><span class="math display">\[\left[\begin{matrix}1 &amp; 1 &amp; 1\\0 &amp; 1 &amp; 2\\0 &amp; 0 &amp; 1\end{matrix} \right]\]</span></p>
<p>Here all the elements below the diagonal of this square matrix is zero. Such matrix is called an <em>upper triangular matrix</em>, usually denoted by <span class="math inline">\(U\)</span>. Similarly, a square matrix that all the elements below the diagonal of this square matrix is zero is called <em>lower triangular matrix</em>, denoted by <span class="math inline">\(L\)</span>. We can use the <code>is_triu</code> and <code>is_tril</code> to verify if a matrix is triangular.</p>
<p>The diagonal elements of <span class="math inline">\(U\)</span> are called pivots. The i-th pivot is the coefficient of the i-th variable in the i-th equation at the i-th step during the elimination.</p>
<p>In general, a square matrix can often be factorised into the dot product of a lower and a upper triangular matrices: <span class="math inline">\(A = LU\)</span>. It is called the <em>LU factorisation</em>. It embodies the process of Gauss elimination. Back to the initial problem of solving the linear equation <span class="math inline">\(Ax=b\)</span>. One reason the LU Factorisation is important is that if the matrix A in <span class="math inline">\(Ax=b\)</span> is triangular, then solving it would be straightforward, as we have seen in the previous example. Actually, we can use <code>triangular_solve</code> to efficiently solve the linear equations if we already know that the matrix is triangular.</p>
<p>For a normal square matrix that can be factorised into <span class="math inline">\(LU\)</span>, we can change <span class="math inline">\(Ax=b\)</span> to <span class="math inline">\(LUx=b\)</span>. First we can find column vector <span class="math inline">\(c\)</span> so that <span class="math inline">\(Lc=b\)</span>, then we can find <span class="math inline">\(x\)</span> so that <span class="math inline">\(Ux=c\)</span>. Both triangular equations are easy to solve.</p>
<p>We use the <code>lu</code> function to perform the LU factorisation. Let’s use the previous example.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let a = [|2.;2.;2.;2.;2.;3.;3.;4.;5.|];;
&gt;val a : float array = [|2.; 2.; 2.; 2.; 2.; 3.; 3.; 4.; 5.|]
let a = Arr.of_array a [|3; 3|];;
&gt;val a : Arr.arr =
&gt;   C0 C1 C2
&gt;R0  2  2  2
&gt;R1  2  2  3
&gt;R2  3  4  5
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let l, u, p = Linalg.D.lu a;;
&gt;val l : Owl_dense_matrix_d.mat =
&gt;
&gt;         C0 C1 C2
&gt;R0        1  0  0
&gt;R1 0.666667  1  0
&gt;R2 0.666667  1  1
&gt;
&gt;val u : Owl_dense_matrix_d.mat =
&gt;
&gt;   C0        C1        C2
&gt;R0  3         4         5
&gt;R1  0 -0.666667 -0.333333
&gt;R2  0         0        -1
&gt;
&gt;val p : Linalg.D.int32_mat =
&gt;   C0 C1 C2
&gt;R0  3  2  3
</code></pre>
</div>
<p>The first two returned matrix are the lower and upper triangular matrices. However, if we try to check the correctness of this factorisation with dot product, the result does not fit:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let a' = Mat.dot l u ;;
&gt;val a' : Mat.mat =
&gt;   C0 C1 C2
&gt;R0  3  4  5
&gt;R1  2  2  3
&gt;R2  2  2  2
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">a' = a;;
&gt;- : bool = false
</code></pre>
</div>
<p>It turns out that we need to some extra row exchange to get the right answer. That’s because the row exchange is required in certain cases, such as when the number we want to use as the pivot could be zero. This process is called <em>pivoting</em>. It is closely related to the numerical computation stability. Choosing the improper pivots can lead to wrong linear system solution. It can be expressed with a permutation matrix that has the same rows as the identity matrix, each row and column has exactly one “1” element. The full LU factorisation can be expressed as:</p>
<p><span class="math display">\[PA = LU.\]</span></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let p = Mat.of_array  [|0.;0.;1.;0.;1.;0.;1.;0.;0.|] 3 3;;
&gt;val p : Mat.mat =
&gt;   C0 C1 C2
&gt;R0  0  0  1
&gt;R1  0  1  0
&gt;R2  1  0  0
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.dot p a = Mat.dot l u ;;
&gt;- : bool = true
</code></pre>
</div>
<p>How do we translate the third output, the permutation vector, to the required permutation matrix? Each element <span class="math inline">\(p_i\)</span> in the vector represents a updated identity matrix. On this identity matrix, we set (i, i) and (<span class="math inline">\(p_i\)</span>, <span class="math inline">\(p_i\)</span>) to zero, and then (i, <span class="math inline">\(p_i\)</span>) and (<span class="math inline">\(p_i\)</span>, i) to one. Multiply these <span class="math inline">\(n\)</span> matrices, we can get the permutation matrix <span class="math inline">\(P\)</span>. Here is a brief implementation of this process in OCaml:</p>
<div class="highlight">
<pre><code class="language-ocaml">let perm_vec_to_mat vec =
    let n = Array.length vec in
    let mat = ref (Mat.eye n) in
    for i = n - 1 downto 0 do
      let j = vec.(i) in
      let a = Mat.eye n in
      Arr.set a [| i; i |] 0.;
      Arr.set a [| j; j |] 0.;
      Arr.set a [| i; j |] 1.;
      Arr.set a [| j; i |] 1.;
      mat := Arr.dot a !mat
    done;
    !mat</code></pre>
</div>
<p>Note that there is more than one way to do the LU factorisation. For example, for the same matrix, we can have:</p>
<p><span class="math display">\[\left[\begin{matrix}1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1\\0 &amp; 1 &amp; 0\end{matrix} \right] \left[\begin{matrix}2 &amp; 2 &amp; 2\\2 &amp; 2 &amp; 3\\3 &amp; 4 &amp; 5\end{matrix} \right] = \left[\begin{matrix}1 &amp; 0 &amp; 0\\1.5 &amp; 1 &amp; 0\\1 &amp; 0 &amp; 1\end{matrix} \right] \left[\begin{matrix}2 &amp; 2 &amp; 2\\0 &amp; 1 &amp; 2\\0 &amp; 0 &amp; 1\end{matrix} \right]\]</span></p>
</section>
<section class="level3" id="inverse-and-transpose">
<h3>Inverse and Transpose</h3>
<p>The concept of inverse matrix is related with the identity matrix, which can be built with <span class="math inline">\(Mat.eye n\)</span>, where n is the size of the square matrix. The identity matrix is a special form of <em>Diagonal Matrix</em>, which is a square matrix that only contains non-zero element along its diagonal. You can check if a matrix is diagonal with <code>is_diag</code> function.</p>
<div class="highlight">
<pre><code class="language-ocaml">Mat.eye 5 |&gt; Linalg.D.is_diag</code></pre>
</div>
<p>The inverse of a <span class="math inline">\(n\)</span> by <span class="math inline">\(n\)</span> square matrix <span class="math inline">\(A\)</span> is denoted by $A^{-1}, so that $: <span class="math inline">\(AA^{-1} = I_n\)</span>. Note that not all square matrix has inverse.<br>
There are many sufficient and necessary conditions to decide if <span class="math inline">\(A\)</span> is invertible, one of them is that A has <span class="math inline">\(n\)</span> pivots.</p>
<p>We use function <code>inv</code> to do the inverse operation. It’s straightforward and easy to verify according to the definition. Here we use the <code>semidef</code> function to produce a matrix that is certainly invertible.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Mat.semidef 5;;
&gt;val x : Mat.mat =
&gt;
&gt;         C0       C1       C2       C3       C4
&gt;R0  1.38671 0.865127  1.58151  1.49422 0.469741
&gt;R1 0.865127 0.708478  1.06377  1.05908 0.284205
&gt;R2  1.58151  1.06377   1.9197  1.75276 0.725455
&gt;R3  1.49422  1.05908  1.75276  2.09053 0.674717
&gt;R4 0.469741 0.284205 0.725455 0.674717 0.825211
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let y = Linalg.D.inv x;;
&gt;val y : Owl_dense_matrix_d.mat =
&gt;
&gt;         C0       C1       C2       C3       C4
&gt;R0   55.544  34.8501 -61.4899 -12.4567  20.6214
&gt;R1  34.8501  34.8324 -44.6476 -10.2098  15.7638
&gt;R2 -61.4899 -44.6476  73.3611   13.064 -24.7952
&gt;R3 -12.4567 -10.2098   13.064  5.27679  -5.1921
&gt;R4  20.6214  15.7638 -24.7952  -5.1921  10.0873
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.(x *@ y =~ eye 5);;
&gt;- : bool = true
</code></pre>
</div>
<p>The next frequently used special matrix is the <em>Transpose Matrix</em>. Denoted by <span class="math inline">\(A^T\)</span>, its <span class="math inline">\(i\)</span>th row is taken from the <span class="math inline">\(i\)</span>-th column of the original matrix A. It has properties such as <span class="math inline">\((AB)^T=B^T~A^T\)</span>. We can check this property using the matrix function <code>Mat.transpose</code>. Note that this function is deemed basic ndarray operations and is not included in the <code>Linalg</code> module.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let flag = 
  let a = Mat.uniform 4 4 in 
  let b = Mat.uniform 4 4 in 
  let m1 = Mat.(dot a b |&gt; transpose) in
  let m2 = Mat.(dot (transpose b) (transpose a)) in 
  Mat.(m1 =~ m2)
;;
&gt;val flag : bool = true
</code></pre>
</div>
<p>A related special matrix is the <em>Symmetric Matrix</em>, which equals to its own transpose. This simple test can be done with the <code>is_symmetric</code> function.</p>
</section>
</section>
<section class="level2" id="vector-spaces">
<h2>Vector Spaces</h2>
<p>We have talked about solving the <span class="math inline">\(Ax=b\)</span> linear equations with elimination, and A is a square matrix. Now we need to further discuss, how do we know if there exists one or maybe more than one solution. To answer such question, we need to be familiar with the concepts of <em>vector space</em>.</p>
<p>A vector space, denoted by <span class="math inline">\(R^n\)</span>, contains all the vectors that has <span class="math inline">\(n\)</span> elements. In this vector space we have the <code>add</code> and <code>multiplication</code> operation. Applying them to the vectors is called <em>linear combination</em>. Then a <em>subspace</em> in a vector space is a non-empty set that linear combination of the vectors in this subspace still stays in the same subspace.</p>
<p>There are four fundamental subspaces concerning solving linear systems $Ax=b, where <span class="math inline">\(A\)</span> is a <span class="math inline">\(m\)</span> by <span class="math inline">\(n\)</span> matrix. The <em>column space</em> consists of all the linear combinations of the columns of A. It is a subspace of <span class="math inline">\(R^m\)</span>. Similarly, the <em>row space</em> consists of all the linear combinations of the rows of A. The <em>nullspace</em> contains all the vectors <span class="math inline">\(x\)</span> so that <span class="math inline">\(Ax=0\)</span>, denoted by <span class="math inline">\(N(A)\)</span>. It is a subspace of <span class="math inline">\(R^n\)</span>. The <em>left nullspace</em> is similar. It is the nullspace of <span class="math inline">\(A^T\)</span>.</p>
<section class="level3" id="rank-and-basis">
<h3>Rank and Basis</h3>
<p>In the Gaussian Elimination section, we assume an ideal situation: the matrix A is <span class="math inline">\(n\times~n\)</span> square, and we assume that there exists one solution. But that does not happen every time. In many cases <span class="math inline">\(A\)</span> is not an square matrix. It is possible that these <span class="math inline">\(m\)</span> equations are not enough to solve a <span class="math inline">\(n\)</span>-variable linear system when <span class="math inline">\(m &lt; n\)</span>. Or there might not exist a solution when <span class="math inline">\(m &gt; n\)</span>. Besides, even it is a square matrix, the information provided by two of the equations are actually repeated. For example, one equation is simply a multiplication of the other.</p>
<p>For example, if we try to apply LU factorisation to such a matrix:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Mat.of_array [|1.; 2.; 3.; 0.; 0.; 1.; 0.; 0.; 2.|] 3 3;;
&gt;val x : Mat.mat =
&gt;   C0 C1 C2
&gt;R0  1  2  3
&gt;R1  0  0  1
&gt;R2  0  0  2
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Linalg.D.lu x;;
&gt;Exception: Failure "LAPACKE: 2".
</code></pre>
</div>
<p>Obviously, we cannot have pivot in the second column, and therefore this matrix is singular and cannot be factorised into <span class="math inline">\(LU\)</span>. As can be seen in this example, we cannot expect the linear algebra functions to be a magic lamb and do our bidding every time. Understanding the theory of linear algebra helps to better understand how these functions work.</p>
<p>To decide the general solutions to <span class="math inline">\(Ax=b\)</span>, we need to understand the concept of <em>rank</em>. The rank of a matrix is the number of pivots in the elimination process. To get a more intuitive understanding of rank, we need to know the concept of *linear independent. In a linear combination <span class="math inline">\(\sum_{i=1}^nc_iv_i\)</span> where <span class="math inline">\(v_i\)</span> are vectors and <span class="math inline">\(c_i\)</span> are numbers, if <span class="math inline">\(\sum_{i=1}^nc_iv_i = 0\)</span> only happens when <span class="math inline">\(c_i = 0\)</span> for all the <span class="math inline">\(i\)</span>’s, then the vectors <span class="math inline">\(v_1, v_2, \ldots, v_n\)</span> are linearly independent. Then the rank of a matrix is the number of independent rows in the matrix. We can understand rank as the number of “effective” rows in the matrix.</p>
<p>As an example, we can check the rank of the previous matrix.</p>
<div class="highlight">
<pre><code class="language-ocaml">Linalg.D.rank x</code></pre>
</div>
<p>As can be example, the rank is 2, which means only two effective rows, and thus cannot be factorised to find the only solution.</p>
<p>One application of rank is in a crucial linear algebra idea: basis. A sequence of vectors is the <em>basis</em> of a space or subspace if: 1) these vectors are linear independent and 2) all the the vectors in the space can be represented as the linear combination of vectors in the basis.</p>
<p>A space can have infinitely different bases, but the number of vectors in these bases are the same. This number is called the <em>dimension</em> of this vector space. For example, a <span class="math inline">\(m\)</span> by <span class="math inline">\(n\)</span> matrix A has rank of <span class="math inline">\(r\)</span>, then the dimension of its null space is <span class="math inline">\(n-r\)</span>, and the dimension of its column space is <span class="math inline">\(r\)</span>. Think about a full-rank matrix where <span class="math inline">\(r=n\)</span>, then the dimension of column matrix is <span class="math inline">\(n\)</span>, which means all its columns can be a basis of the column space, and that the null space dimension is zero so that the only solution of <span class="math inline">\(Ax=0\)</span> is a zero vector.</p>
</section>
<section class="level3" id="orthogonality">
<h3>Orthogonality</h3>
<p>We can think of the basis of a vector space as the Cartesian coordinate system in a three-dimensional space, where every vector in the space can be represented with the three vectors ni the space: the x, y and z axis. Actually, we can use many three vectors system as the coordinate bases, but the x. y, z axis is used is because they are orthogonal to each other. An orthogonal basis can greatly reduce the complexity of problems. The same can be applied in the basis of vector spaces.</p>
<p>Orthogonality is not limited to vectors. Two vectors <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are orthogonal are orthogonal if <span class="math inline">\(a^Tb = 0\)</span>. Two subspaces A and B are orthogonal if every vector in A is orthogonal to every vector in B. For example, the nullspace and row space of a matrix are perpendicular to each other.</p>
<p>Among the bases of a subspace, if every vector is perpendicular to each other, it is called an orthogonal matrix. Moreover, if the length of each vector is normalised to one unit, it becomes the <em>orthonormal basis</em>.</p>
<p>For example, we can use the <code>null</code> function to find an orthonormal basis vector <span class="math inline">\(x\)</span> or the null space of a matrix, i.e.&nbsp;<span class="math inline">\(Ax=0\)</span>.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let a = Mat.magic 4;;
&gt;val a : Mat.mat =
&gt;
&gt;   C0 C1 C2 C3
&gt;R0  1 15 14  4
&gt;R1 12  6  7  9
&gt;R2  8 10 11  5
&gt;R3 13  3  2 16
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let x = Linalg.D.null a;;
&gt;val x : Owl_dense_matrix_d.mat =
&gt;
&gt;          C0
&gt;R0 -0.223607
&gt;R1  -0.67082
&gt;R2   0.67082
&gt;R3  0.223607
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Mat.dot a x |&gt; Mat.l2norm' ;;
&gt;- : float = 2.87802701599908967e-15
</code></pre>
</div>
<p>(Question: but this example does not really show the orthogonal part.)</p>
<p>Now that we know what is orthogonal basis, the next question is, how to build one? The method to construct orthogonal basis in a subspace is called the <em>Gram-Schmidt orthogonalisation</em>.</p>
<p>TODO: Explain Gram-Schmidt and QR.</p>
<div class="highlight">
<pre><code class="language-clike">val qr : ?thin:bool -&gt; ?pivot:bool -&gt; ('a, 'b) t -&gt; ('a, 'b) t * ('a, 'b) t * (int32, int32_elt) t</code></pre>
</div>
<p><code>qr x</code> calculates QR decomposition for an <code>m</code> by <code>n</code> matrix <code>x</code>. The function returns a 3-tuple, the first two are <code>Q</code> and <code>R</code>, and the third is the permutation vector of columns. The default value of parameter <code>pivot</code> is <code>false</code>, setting pivot to true lets <code>qr</code> performs pivoted factorisation. Note that the returned indices are not adjusted to 0-based C layout. By default, <code>qr</code> performs a reduced QR factorisation, full factorisation can be enabled by setting <code>thin</code> parameter to <code>false</code>.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let a = Mat.of_array [|12.; -51.; 4.; 6.; 167.; -68.; -4.; 24.; -41.|] 3 3 ;;
&gt;val a : Mat.mat =
&gt;
&gt;   C0  C1  C2
&gt;R0 12 -51   4
&gt;R1  6 167 -68
&gt;R2 -4  24 -41
</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let q, r, _ = Linalg.D.qr a;;
&gt;val q : Owl_dense_matrix_d.mat =
&gt;
&gt;          C0        C1         C2
&gt;R0 -0.857143  0.394286   0.331429
&gt;R1 -0.428571 -0.902857 -0.0342857
&gt;R2  0.285714 -0.171429   0.942857
&gt;
&gt;val r : Owl_dense_matrix_d.mat =
&gt;
&gt;    C0   C1  C2
&gt;R0 -14  -21  14
&gt;R1   0 -175  70
&gt;R2   0    0 -35
</code></pre>
</div>
</section>
<section class="level3" id="solving-ax-b">
<h3>Solving Ax = b</h3>
<p>We can now discuss the general solution to <span class="math inline">\(Ax=b\)</span>.</p>
<p>Several theorems: There exist non-zero solutions to <span class="math inline">\(Ax=0\)</span> if and only if rank(A) &lt; column of A.</p>
<p>Example</p>
<p>Suppose A is mxn matrix, and b is mx1 matrix, then there exist solution if and only if r(A) = r([A, b]). If and only if r(A) also equals to n, there exist one solution.</p>
<p><code>linsolve a b -&gt; x</code> solves a linear system of equations <code>a * x = b</code> in the following form. By default, <code>typ=n</code> and the function use LU factorisation with partial pivoting when <code>a</code> is square and QR factorisation with column pivoting otherwise. The number of rows of <code>a</code> must equal the number of rows of <code>b</code>. If <code>a</code> is a upper(lower) triangular matrix, the function calls the <code>solve_triangular</code> function.</p>
<div class="highlight">
<pre><code class="language-clike">val linsolve : ?trans:bool -&gt; ('a, 'b) t -&gt; ('a, 'b) t -&gt; ('a, 'b) t</code></pre>
</div>
<p>Example: only using the function does not work; you have to do some comparison of rank.</p>
</section>
</section>
<section class="level2" id="determinants">
<h2>Determinants</h2>
<p>For a square matrix. the definition of <em>determinants</em>:</p>
<p>EQUATION</p>
<p>There are many techniques to simplify this calculation. But we use the <code>det</code> function here to calculate the determinants of a matrix.</p>
<p>There is a similar function <code>logdet</code>. It computes the logarithm of the determinant, but it avoids the possible overflow or underflow problems in computing determinant of large matrices.</p>
<p>Why is this concept important? We use the determinant to calculate the solution to Ax=b.</p>
<p>Cramer’s rule.</p>
<p>Example: using <code>solve</code> and <code>det</code> to solve a Ax=b.</p>
<p>Another important application is to use determinant to decide if a square matrix A is invertible/singular. A is invertible if and only if <span class="math inline">\(|A|\)</span> does not equal to 0.</p>
<p>This theorem is widely used in finding <em>eigenvalues</em>. As will be shown in the next section.</p>
</section>
<section class="level2" id="eigenvalues-and-eigenvectors">
<h2>Eigenvalues and Eigenvectors</h2>
<p>Now we change from <span class="math inline">\(Ax=b\)</span> to <span class="math inline">\(Ax=\lambda~x\)</span>.</p>
<p>We use ODE system as an example. (Following the Textbook)</p>
<p>It can be written as:</p>
<p><span class="math inline">\((A - \lambda~I)x = 0\)</span></p>
<p>If there exist number <span class="math inline">\(\lambda\)</span> and non-zero column vector <span class="math inline">\(x\)</span> to satisfy this equation, then <span class="math inline">\(\lambda\)</span> is called <em>eigenvalue</em>, and <span class="math inline">\(x\)</span> is called the <em>eigenvector</em> of this matrix A.</p>
<p>Continue the previous example to solve it manually.</p>
<p>According to the theory of polynomials, equation xx has and only has n roots in the complex space.</p>
<p>And we have function <code>eig</code> and <code>eigbvals</code> to do that:</p>
CODE: using these functions to repeat the previous example.
<div class="highlight">
<pre><code class="language-text">
  val eig : ?permute:bool -&gt; ?scale:bool -&gt; otyp:('a, 'b) kind -&gt; ('c, 'd) t -&gt; ('a, 'b) t * ('a, 'b) t
  (* right eigenvectors and eigenvalues of an arbitrary square matrix *)

  val eigvals : ?permute:bool -&gt; ?scale:bool -&gt; otyp:('a, 'b) kind -&gt; ('c, 'd) t -&gt; ('a, 'b) t
  (* only computes the eigenvalues of an arbitrary square matrix *)</code></pre>
</div>
<p>Once we get the eigenvalue, we can return to the solution to ODE: A linear combination.</p>
<section class="level3" id="diagonalisation">
<h3>Diagonalisation</h3>
<p>Diagonal matrix is the easiest to deal with. Several properties….</p>
<p>Diagonalisation</p>
<p>Use one example to demonstrate how to solve the ODE system with diagonalisation.</p>
<p>That leads to a brief discussion of stability with eigenvalues. Explain the intuition why Eigenvalue is important in different fields.</p>
</section>
<section class="level3" id="complex-matrices">
<h3>Complex Matrices</h3>
<p>Eigenvalue and vector in the complex space.</p>
<p>Hermitian: extend the transpose to complex space. Matrix that equal their conjugate transpose.</p>
<div class="highlight">
<pre><code class="language-clike">  val is_hermitian : ('a, 'b) t -&gt; bool
  (* check if a matrix is hermitian *)</code></pre>
</div>
<p>Definition of Unitary matrices: <span class="math inline">\(UU^H=I\)</span></p>
<p>Example of using eig on complex matrices.</p>
</section>
<section class="level3" id="similarity-transformation">
<h3>Similarity Transformation</h3>
<p>Definition: Similar matrix. The point is to make clear its intuition: change basis, linear transformation. And transforming to diagonal is the easiest.</p>
<p>A property: if <span class="math inline">\(A = A^H\)</span>, every eigenvalue is real. And that a real symmetric matrix can be factored into <span class="math inline">\(A=Q\lambda~Q^T\)</span>.</p>
<div class="highlight">
<pre><code class="language-clike">  val schur : otyp:('c, 'd) kind -&gt; ('a, 'b) t -&gt; ('a, 'b) t * ('a, 'b) t * ('c, 'd) t
  (* Schur factorisation *)</code></pre>
</div>
<p>Example. If possible, shows how similar matrix simplify the problem.</p>
<p>Jordan form: very brief explain.</p>
</section>
</section>
<section class="level2" id="positive-definite-matrices">
<h2>Positive Definite Matrices</h2>
<section class="level3" id="positive-definiteness">
<h3>Positive Definiteness</h3>
<p>In this section we introduce <em>Positive Definite Matrix</em>, which unifies the three most basic ideas in linear algebra: pivots, determinants, and eigenvalues.</p>
<p>The definition of a Positive Definite Matrix: symmetric, <span class="math inline">\(x^TAx &gt; 0\)</span> for all non-zero vectors <span class="math inline">\(x\)</span>. There are several necessary and sufficient condition for testing if a symmetric matrix A is positive definite:</p>
<ol type="1">
<li><span class="math inline">\(x^TAx&gt;0\)</span> for all non-zero real vectors x</li>
<li><span class="math inline">\(\lambda_i &gt;0\)</span> for all eigenvalues <span class="math inline">\(\lambda_i\)</span> of A</li>
<li>all the upper left matrices have positive determinants</li>
<li>all the pivots without row exchange satisfy <span class="math inline">\(d &gt;0\)</span></li>
<li>there exists invertible matrix B so that A=B^TB</li>
</ol>
For the last condition, we can use <em>Cholesky decomposition</em> to find B:
<div class="highlight">
<pre><code class="language-clike">val chol : ?upper:bool -&gt; ('a, 'b) t -&gt; ('a, 'b) t
  (* Cholesky factorisation *)</code></pre>
</div>
<p>Example</p>
<p>In the Linear Algebra module, we use <code>is_posdef</code> to do this test.</p>
<div class="highlight">
<pre><code class="language-clike">val is_posdef : ('a, 'b) t -&gt; bool
  (* check if a matrix is positive semi-definite *)</code></pre>
</div>
<p>It’s implementation uses …</p>
<p>Similar, the definition of semi-positive definite.</p>
<p>The positive definite matrices are frequently used in different fields. The pattern <span class="math inline">\(Ax=\lambda~Mx\)</span> exists in many engineering analysis problems. If <span class="math inline">\(A\)</span> and <span class="math inline">\(M\)</span> are positive definite, this pattern is parallel to the <span class="math inline">\(Ax=\lambda~x\)</span> where <span class="math inline">\(\lambda &gt; 0\)</span>.</p>
<p>One such application is the stability of motion. Definition of stable system.</p>
<p>In a linear system:</p>
<p><span class="math display">\[y' = Ax\]</span></p>
<p>(extend this equation)</p>
<p>A theorem declares that this system is stable if and only if there exists positive and definite matrix <span class="math inline">\(V\)</span> so that <span class="math inline">\(-(VA+A^TV)\)</span> is semi-positive definite.</p>
<p>The pendulum example</p>
</section>
<section class="level3" id="singular-value-decomposition">
<h3>Singular Value Decomposition</h3>
<p>The singular value decomposition (SVD) is among the most important matrix factorizations of the computational era. The SVD provides a numerically stable matrix decomposition that can be used for a variety of purposes and is guaranteed to exist.</p>
<p>Definition of SVD</p>
<p>It’s close related with eigenvector factorisation of a positive definite matrix. Detail.</p>
<p>What we provide:</p>
<div class="highlight">
<pre><code class="language-text">  val svd : ?thin:bool -&gt; ('a, 'b) t -&gt; ('a, 'b) t * ('a, 'b) t * ('a, 'b) t
  (* singular value decomposition *)

  val svdvals : ('a, 'b) t -&gt; ('a, 'b) t
  (* only singular values of SVD *)

  val gsvd : ('a, 'b) t -&gt; ('a, 'b) t -&gt; ('a, 'b) t * ('a, 'b) t * ('a, 'b) t * ('a, 'b) t * ('a, 'b) t * ('a, 'b) t
  (* generalised singular value decomposition *)

  val gsvdvals : ('a, 'b) t -&gt; ('a, 'b) t -&gt; ('a, 'b) t
  (* only singular values of generalised SVD *)
</code></pre>
</div>
<p>The following code performs an SVD on a random matrix then check the equality.</p>
<div class="highlight">
<pre><code class="language-ocaml">  let x = Mat.uniform 8 16;;        (* generate a random matrix *)
  let u, s, vt = Linalg.D.svd x;;   (* perform lq decomposition *)
  let s = Mat.diagm s;;             (* exapand to diagonal matrix *)
  Mat.(u *@ s *@ vt =~ x);;         (* check the approx equality *)</code></pre>
</div>
<p>The intuition of SVD.</p>
<p>Applications. Many applications; ….</p>
The Moore-Penrose inverse is a direct application of the SVD.
<div class="highlight">
<pre><code class="language-clike">val pinv : ?tol:float -&gt; ('a, 'b) t -&gt; ('a, 'b) t
  (* Moore-Penrose pseudo-inverse of a matrix *)</code></pre>
</div>
<p>It is also related to the least square.</p>
<p>We will also come back to SVD in NLP.</p>
</section>
</section>
<section class="level2" id="computations-with-matrices">
<h2>Computations with Matrices</h2>
<section class="level3" id="matrix-norm-and-condition-number">
<h3>Matrix Norm and Condition Number</h3>
<div class="highlight">
<pre><code class="language-text">
  val norm : ?p:float -&gt; ('a, 'b) t -&gt; float
  (* p-norm of a matrix *)

  val cond : ?p:float -&gt; ('a, 'b) t -&gt; float
  (* p-norm condition number of a matrix *)

  val rcond : ('a, 'b) t -&gt; float
  (* estimate for the reciprocal condition of a matrix in 1-norm *)</code></pre>
</div>
<p><strong>Hessenberg Factorisations:</strong></p>
<div class="highlight">
<pre><code class="language-clike">val hess : ('a, 'b) t -&gt; ('a, 'b) t * ('a, 'b) t
  (* Hessenberg form of a given matrix *)</code></pre>
</div>
</section>
</section>
<section class="level2" id="linear-programming">
<h2>Linear Programming</h2>
<p>TODO: placeholder for future implementation. Or in the optimisation chapter. Understand the method used such as interior point, and then make the decision.</p>
</section>
<section class="level2" id="internal-cblas-and-lapacke">
<h2>Internal: CBLAS and LAPACKE</h2>
<p>This section is for those of you who are eager for more low level information.</p>
<p>The Background: BLAS, a brief history. How we include that into Owl.</p>
<section class="level3" id="low-level-interface-to-cblas-lapacke">
<h3>Low-level Interface to CBLAS &amp; LAPACKE</h3>
<p>Owl has implemented the full interface to CBLAS and LAPACKE. Comparing to Julia which chooses to interface to BLAS/LAPACK, you might notice the extra <code>C</code> in <code>CBLAS</code> and <code>E</code> in <code>LAPACKE</code> because they are the corresponding C-interface of Fortran implementations. It is often believed that C-interface may introduce some extra overhead. However, it turns out that we cannot really notice any difference at all in practice when dealing with medium or large problems.</p>
<ul>
<li><p><a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/cblas/owl_cblas.mli">Owl_cblas module</a> provides the raw interface to CBLAS functions, from level-1 to level-3. The interfaced functions have the same names as those in CBLAS.</p></li>
<li><p><a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/lapacke/owl_lapacke_generated.mli">Owl_lapacke_generated module</a> provides the raw interface to LAPACKE functions (over 1,000) which also have the same names defined in <a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/lapacke/lapacke.h">lapacke.h</a>.</p></li>
<li><p><a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/lapacke/owl_lapacke.ml">Owl_lapacke module</a> is a very thin layer of interface between <a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/lapacke/owl_lapacke_generated.mli">Owl_lapacke_generated module</a> and <a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/linalg/owl_linalg_generic.mli">Linalg module</a>. The purpose is to provide a unified function to make generic functions over different number types.</p></li>
</ul>
</section>
<section class="level3" id="high-level-wrappers-in-linalg-module">
<h3>High-level Wrappers in Linalg Module</h3>
<p>The functions in <a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/cblas/owl_cblas.mli">Owl_cblas</a> and <a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/lapacke/owl_lapacke_generated.mli">Owl_lapacke_generated</a> are very low-level, e.g., you need to deal with calculating parameters, allocating workspace, post-processing results, and many other tedious details. You do not really want to use them directly unless you have enough background in numerical analysis and chase after the performance. In practice, you should use <a href="https://github.com/ryanrhymes/owl/blob/master/src/owl/linalg/owl_linalg_generic.mli">Linalg</a> module which gives you a high-level wrapper for frequently used functions.</p>
</section>
<section class="level3" id="low-level-factorisation-and-helper-functions">
<h3>Low-level factorisation and Helper functions</h3>
<div class="highlight">
<pre><code class="language-text">
  val lufact : ('a, 'b) t -&gt; ('a, 'b) t * (int32, int32_elt) t

  val qrfact : ?pivot:bool -&gt; ('a, 'b) t -&gt; ('a, 'b) t * ('a, 'b) t * (int32, int32_elt) t

  val bkfact : ?upper:bool -&gt; ?symmetric:bool -&gt; ?rook:bool -&gt; ('a, 'b) t -&gt; ('a, 'b) t * (int32, int32_elt) t

  val peakflops : ?n:int -&gt; unit -&gt; float
  (* peak number of float point operations using [Owl_cblas.dgemm] function. *)
</code></pre>
</div>
<p>How these low level functions are used in Owl Code.</p>
</section>
</section>
<section class="level2" id="sparse-matrices">
<h2>Sparse Matrices</h2>
<p>Very brief. Focusing on introducing the data structure (CSC, CSR, etc), no the method.</p>
<p>Mention the <a href="https://github.com/owlbarn/owl_suitesparse">owl_suitesparse</a></p>
<ul>
<li><code>Sparse.Matrix.S</code> : Sparse matrices of single precision float numbers.</li>
<li><code>Sparse.Matrix.D</code> : Sparse matrices of double precision float numbers.</li>
<li><code>Sparse.Matrix.C</code> : Sparse matrices of single precision complex numbers.</li>
<li><code>Sparse.Matrix.Z</code> : Sparse matrices of double precision complex numbers.</li>
</ul>
<p>TODO: Introduce the sparse data structure in owl, and introduce CSR, CSC, tuples, and other formats.</p>
<p><strong>extra material on LQ</strong></p>
<div class="highlight">
<pre><code class="language-text">  val lq : ?thin:bool -&gt; ('a, 'b) t -&gt; ('a, 'b) t * ('a, 'b) t
  (* LQ factorisation *)</code></pre>
</div>
<p>The following code performs an LQ decomposition on a random square matrix. Note that in the last step we used <code>=~</code> rather than <code>=</code> to check the equality due to float number precision. You can check the difference with <code>Mat.(l *@ q - x)</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">
  let x = Mat.uniform 8 8;;    (* generate a random matrix *)
  let l, q = Linalg.D.lq x;;   (* perform lq decomposition *)
  Mat.(l *@ q =~ x);;          (* check the approx equality *)
</code></pre>
</div>
<div role="doc-bibliography" class="references hanging-indent" id="refs">
<div id="ref-strang2006linear">
<p>Strang, Gilbert. 2006. <em>Linear Algebra and Its Applications</em>. Belmont, CA: Thomson, Brooks/Cole. <a href="http://www.amazon.com/Linear-Algebra-Its-Applications-Edition/dp/0030105676">http://www.amazon.com/Linear-Algebra-Its-Applications-Edition/dp/0030105676</a>.</p>
</div>
</div>
</section>
</section>
</article></div><a href="diffequation.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 09</small>Ordinary Differential Equations</h1></div></a><footer><div class="content"><ul><li><a href="http://ocaml.xyz">ocaml.xyz</a></li><li><a href="https://github.com/ryanrhymes">GitHub</a></li></ul><p>Copyright 2017-2020 Liang Wang.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>